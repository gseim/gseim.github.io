
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Element templates &#8212; GSEIM 0.0.1 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Solve Blocks" href="solve.html" />
    <link rel="prev" title="GSEIM Organisation" href="organisation.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="element-templates">
<span id="templates"></span><h1>Element templates<a class="headerlink" href="#element-templates" title="Permalink to this headline">¶</a></h1>
<p>A very important feature of GSEIM is that it allows the user to
add new functionality in the form of library elements, by
writing suitable <strong>templates</strong>.
In this section, we look at the syntax of element templates
with the help of some examples.</p>
<div class="section" id="xbe-templates">
<h2>xbe templates<a class="headerlink" href="#xbe-templates" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Template files for flow-graph type elements have extension
<code class="docutils literal notranslate"><span class="pre">.xbe</span></code> (<em>explicit basic element</em>), and they are located in
directory <code class="docutils literal notranslate"><span class="pre">$XBE</span></code> (see <a class="reference internal" href="organisation.html#gseimorg"><span class="std std-ref">GSEIM Organisation</span></a>).</li>
<li>A flow-graph element template has three types of variables in general:
input, output, and auxiliary. Only the input and output variables
are made available in the GUI for connection to other elements.</li>
<li>Flow-graph elements can be of two types:<ul>
<li><code class="docutils literal notranslate"><span class="pre">evaluate</span></code> type in which the element equations are of the form
<span class="math notranslate nohighlight">\(y = f(x_1,x_2,..)\)</span>
where <span class="math notranslate nohighlight">\(y\)</span> is an output and
<span class="math notranslate nohighlight">\(x_1\)</span>,
<span class="math notranslate nohighlight">\(x_2\)</span>, etc.
are inputs. These elements do not involve time derivatives.</li>
<li><code class="docutils literal notranslate"><span class="pre">integrate</span></code> type with equations of the form
<span class="math notranslate nohighlight">\(\displaystyle\frac{dy}{dt} = f(x_1,x_2,..)\)</span> where
<span class="math notranslate nohighlight">\(y\)</span> is an
output or auxiliary variable, and
<span class="math notranslate nohighlight">\(x_1\)</span>,
<span class="math notranslate nohighlight">\(x_2\)</span>, etc.
can be input, output, or auxiliary variables.</li>
</ul>
</li>
</ul>
<p>In the following, we look at a few representative examples
to explain the functioning of the <code class="docutils literal notranslate"><span class="pre">xbe</span></code> templates. The
templates described here can be found in directory <code class="docutils literal notranslate"><span class="pre">$XBE</span></code>.</p>
<div class="section" id="sum-2-xbe">
<span id="sum-2"></span><h3>sum_2.xbe<a class="headerlink" href="#sum-2-xbe" title="Permalink to this headline">¶</a></h3>
<p>This element is used to obtain</p>
<div class="math notranslate nohighlight">
\[y = k_1x_1 + k_2x_2,\]</div>
<p>where
<span class="math notranslate nohighlight">\(x_1\)</span>,
<span class="math notranslate nohighlight">\(x_2\)</span> are input variables,
<span class="math notranslate nohighlight">\(y\)</span> is the output variable, and
<span class="math notranslate nohighlight">\(k_1\)</span>,
<span class="math notranslate nohighlight">\(k_2\)</span> are real parameters.
This is an <code class="docutils literal notranslate"><span class="pre">evaluate</span></code> type element, i.e., its output can be written
as a function of its inputs, and it does not involve time derivatives.
The overall structure of <code class="docutils literal notranslate"><span class="pre">sum_2.xbe</span></code> is given below.</p>
<div class="highlight-text notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46</pre></div></td><td class="code"><div class="highlight"><pre><span></span>xbe name=sum_2 evaluate=yes
# y = k1*x1 + k2*x2
Jacobian: constant
input_vars: x1 x2
output_vars: y
aux_vars:
iparms:
sparms:
rparms: k1=1 k2=1
stparms:
igparms:
outparms: x1 x2 y
n_f= 0
n_g= 1
g_1: x1 x2 y
C:
   k1 = X.rprm[nr_k1];
   k2 = X.rprm[nr_k2];
   if (G.flags[G.i_init_guess]) {
     X.val_vr[nvr_y] = k1*X.val_vr[nvr_x1] + k2*X.val_vr[nvr_x2];
     return;
   }
   if (G.flags[G.i_trns] || G.flags[G.i_startup]) {
     if (G.flags[G.i_explicit]) {
       X.val_vr[nvr_y] = k1*X.val_vr[nvr_x1] + k2*X.val_vr[nvr_x2];
     } else if (G.flags[G.i_implicit]) {
       if (G.flags[G.i_function]) {
         X.g[ng_1] = X.val_vr[nvr_y]
           - k1*X.val_vr[nvr_x1] - k2*X.val_vr[nvr_x2];
       }
       if (G.flags[G.i_jacobian]) {
         J.dgdvr[ng_1][nvr_y ] =  1.0;
         J.dgdvr[ng_1][nvr_x1] = -k1;
         J.dgdvr[ng_1][nvr_x2] = -k2;
       }
     }
     return;
   }
   if (G.flags[G.i_outvar]) {
     X.outprm[no_x1] = X.val_vr[nvr_x1];
     X.outprm[no_x2] = X.val_vr[nvr_x2];
     X.outprm[no_y ] = X.val_vr[nvr_y ];
     return;
   }
endC
endxbe
</pre></div>
</td></tr></table></div>
<p>Note the following features in the template:</p>
<ul class="simple">
<li>The element name is specified by the keyword <code class="docutils literal notranslate"><span class="pre">name</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">evaluate=yes</span></code> specifies the element type.</li>
<li>A line starting with <code class="docutils literal notranslate"><span class="pre">#</span></code> is a comment.</li>
<li><code class="docutils literal notranslate"><span class="pre">Jacobian:</span> <span class="pre">constant</span></code> indicates that,
when the element equation
<span class="math notranslate nohighlight">\(y - k_1x_1 - k_2x_2 = 0\)</span>
is differentiated with respect to the variables involved
in the equation, we get constants.</li>
<li>The lines <code class="docutils literal notranslate"><span class="pre">input_vars</span></code> and <code class="docutils literal notranslate"><span class="pre">output_vars</span></code> specify
the input and output variables of the element, respectively.</li>
<li>There are no integers parameters, string parameters, start-up
parameters, initial guess parameters for this element. The
corresponding fields (<code class="docutils literal notranslate"><span class="pre">iparms</span></code>, <code class="docutils literal notranslate"><span class="pre">sparms</span></code>, <code class="docutils literal notranslate"><span class="pre">stparms</span></code>,
<code class="docutils literal notranslate"><span class="pre">igparms</span></code>, respectively) are therefore empty.</li>
<li>The names and default values of the real parameters are given
by the <code class="docutils literal notranslate"><span class="pre">rparms</span></code> statement. (GSEIM also allows integer and
string parameters; they are not used in <code class="docutils literal notranslate"><span class="pre">sum_2</span></code>).</li>
<li>The <code class="docutils literal notranslate"><span class="pre">outparms</span></code> statement specifies the names of output
parameters which will be made available by this template
during simulation (if requested by the user).</li>
<li>The <code class="docutils literal notranslate"><span class="pre">n_f</span></code> and <code class="docutils literal notranslate"><span class="pre">n_g</span></code> statements specify the number
of <code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span></code> functions for this element. (This aspect will be
described in <a class="reference internal" href="#xbe-fgh"><span class="std std-ref">xbe: f, g, h functions</span></a>.)</li>
<li>The <code class="docutils literal notranslate"><span class="pre">g_1</span></code> statement indicates the variables involved in
the function
<span class="math notranslate nohighlight">\(g_1\)</span>.</li>
<li>The C++ section of the template appears
between the <code class="docutils literal notranslate"><span class="pre">C</span></code> and <code class="docutils literal notranslate"><span class="pre">endC</span></code> statements.</li>
</ul>
<p>The behaviour of this element is coded in the C++
section of the template.  In order to understand this section, we need to
see where it fits in the overall scheme, as explained in the following.</p>
<p>There is a GSEIM library preprocessor which picks up the C++ section
of each <code class="docutils literal notranslate"><span class="pre">xbe</span></code> template (as also the other details such as input
and output variables, real parameters, etc.) and uses it to prepare
a C++ routine for that specific <code class="docutils literal notranslate"><span class="pre">xbe</span></code>. All of these <code class="docutils literal notranslate"><span class="pre">xbe</span></code>
routines are then compiled together with the solver code of GSEIM
to prepare the executable file for the solver.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">sum_2</span></code> routine (function) receives objects <code class="docutils literal notranslate"><span class="pre">G</span></code>
and <code class="docutils literal notranslate"><span class="pre">X</span></code> from the GSEIM main program and is expected to compute
various quantities such function values, output parameters, etc.
Objects <code class="docutils literal notranslate"><span class="pre">G</span></code> and <code class="docutils literal notranslate"><span class="pre">X</span></code> may be described as follows.</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">G</span></code> is a global object and is used to pass information
about the current time point, type of method being used (implicit or
explicit), etc. It also conveys to the element routine, through the
<code class="docutils literal notranslate"><span class="pre">flags</span></code> array, what computation the main program is expecting
from the element routine in the present call.</li>
<li><code class="docutils literal notranslate"><span class="pre">X</span></code> is specific to the element being treated, and it contains
variables and parameter values related to that element.</li>
</ul>
<p>With this background, let us now look at the C++ routine
prepared by the library preprocessor for <code class="docutils literal notranslate"><span class="pre">sum_2.xbe</span></code>:</p>
<div class="highlight-text notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43</pre></div></td><td class="code"><div class="highlight"><pre><span></span>void x_sum_2(Global &amp;G,XbeUsr &amp;X,XbeJac &amp;J) {
   double x1,x2;
   double y;
   double k1,k2;
   const int nvr_x1 = 0;
   const int nvr_x2 = 1;
   const int nvr_y = 2;
   const int nr_k1 = 0;
   const int nr_k2 = 1;
   const int no_x1 = 0;
   const int no_x2 = 1;
   const int no_y = 2;
   const int ng_1 = 0;
   k1 = X.rprm[nr_k1];
   k2 = X.rprm[nr_k2];
   if (G.flags[G.i_init_guess]) {
     X.val_vr[nvr_y] = k1*X.val_vr[nvr_x1] + k2*X.val_vr[nvr_x2];
     return;
   }
   if (G.flags[G.i_trns] || G.flags[G.i_startup]) {
     if (G.flags[G.i_explicit]) {
       X.val_vr[nvr_y] = k1*X.val_vr[nvr_x1] + k2*X.val_vr[nvr_x2];
     } else if (G.flags[G.i_implicit]) {
       if (G.flags[G.i_function]) {
         X.g[ng_1] = X.val_vr[nvr_y]
           - k1*X.val_vr[nvr_x1] - k2*X.val_vr[nvr_x2];
       }
       if (G.flags[G.i_jacobian]) {
         J.dgdvr[ng_1][nvr_y ] =  1.0;
         J.dgdvr[ng_1][nvr_x1] = -k1;
         J.dgdvr[ng_1][nvr_x2] = -k2;
       }
     }
     return;
   }
   if (G.flags[G.i_outvar]) {
     X.outprm[no_x1] = X.val_vr[nvr_x1];
     X.outprm[no_x2] = X.val_vr[nvr_x2];
     X.outprm[no_y ] = X.val_vr[nvr_y ];
     return;
   }
   return;
}
</pre></div>
</td></tr></table></div>
<p>Note that the library preprocessor has simply inserted
the C++ section of <code class="docutils literal notranslate"><span class="pre">sum_2.xbe</span></code> into this routine
without any changes. In addition, it has added the following.</p>
<ul class="simple">
<li>declaration for <code class="docutils literal notranslate"><span class="pre">x1</span></code>, <code class="docutils literal notranslate"><span class="pre">x2</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, <code class="docutils literal notranslate"><span class="pre">k1</span></code>, <code class="docutils literal notranslate"><span class="pre">k2</span></code>: This allows
the user to use these variables without having to declare them
manually.</li>
<li>assignment of integers <code class="docutils literal notranslate"><span class="pre">nvr_x1</span></code>, <code class="docutils literal notranslate"><span class="pre">nvr_x2</span></code>, <code class="docutils literal notranslate"><span class="pre">nvr_y</span></code>, <code class="docutils literal notranslate"><span class="pre">nr_k1</span></code>,
<code class="docutils literal notranslate"><span class="pre">nr_k2</span></code> <code class="docutils literal notranslate"><span class="pre">no_x1</span></code>, <code class="docutils literal notranslate"><span class="pre">no_x2</span></code>, <code class="docutils literal notranslate"><span class="pre">no_y</span></code>, <code class="docutils literal notranslate"><span class="pre">ng_1</span></code>: These constants
are convenient in accessing the attributes of the <code class="docutils literal notranslate"><span class="pre">xbe</span></code>. For
example, <code class="docutils literal notranslate"><span class="pre">X.val_vr[nvr_x1]</span></code> gives the current value of <code class="docutils literal notranslate"><span class="pre">x1</span></code> for
this element.</li>
</ul>
<p>It is now easy to see the following points about <code class="docutils literal notranslate"><span class="pre">sum_2.xbe</span></code>:</p>
<ul>
<li><p class="first">If an explicit method is being used, the template
evaluates <code class="docutils literal notranslate"><span class="pre">y</span></code> in terms of <code class="docutils literal notranslate"><span class="pre">x1</span></code> and <code class="docutils literal notranslate"><span class="pre">x2</span></code>.</p>
</li>
<li><p class="first">If an implicit method is being used, the template supplies
information about the equation it satisfies, viz.,</p>
<div class="math notranslate nohighlight">
\[g_1 \equiv y - (k_1x_1 + k_2x_2) = 0.\]</div>
<p>If the main program is requesting the function value,
<span class="math notranslate nohighlight">\(g_1(x_1,x_2,y)\)</span> is
evaluated; if it is requesting the derivatives, then
<span class="math notranslate nohighlight">\(\displaystyle\frac{\partial g_1}{\partial x_1}\)</span>,
<span class="math notranslate nohighlight">\(\displaystyle\frac{\partial g_1}{\partial x_2}\)</span>,
<span class="math notranslate nohighlight">\(\displaystyle\frac{\partial g_1}{\partial y}\)</span>
are evaluated.</p>
</li>
<li><p class="first">If the program is requesting assignment of output parameters, the
parameters listed in the <code class="docutils literal notranslate"><span class="pre">outparms</span></code> statement of <code class="docutils literal notranslate"><span class="pre">sum_2.xbe</span></code>
are assigned.</p>
</li>
</ul>
</div>
<div class="section" id="integrator-xbe">
<h3>integrator.xbe<a class="headerlink" href="#integrator-xbe" title="Permalink to this headline">¶</a></h3>
<p>Next, we consider an element of type <code class="docutils literal notranslate"><span class="pre">integrate</span></code>, viz., the
integrator, which satisfies</p>
<div class="math notranslate nohighlight" id="equation-eq-integrator">
<span class="eqno">(1)<a class="headerlink" href="#equation-eq-integrator" title="Permalink to this equation">¶</a></span>\[y = k\,\int x\,dt,\]</div>
<p>where <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> are the input and
output variables, respectively, and <code class="docutils literal notranslate"><span class="pre">k</span></code> is a real parameter.
Since GSEIM expects the equations to be written
in the general form</p>
<div class="math notranslate nohighlight">
\[\displaystyle\frac{dy}{dt} = f(x_1,x_2,..),\]</div>
<p>we rewrite Eq. <a class="reference internal" href="#equation-eq-integrator">(1)</a> as</p>
<div class="math notranslate nohighlight">
\[\displaystyle\frac{dy}{dt} = \,k\,x.\]</div>
<p>For <code class="docutils literal notranslate"><span class="pre">integrate</span></code> type elements, we also need to specify
the initial or <em>start-up</em> value of the state variable(s).
For the integrator, we will denote that by <span class="math notranslate nohighlight">\(y_0\)</span>.</p>
<p>The integrator template is shown below.</p>
<div class="highlight-text notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63</pre></div></td><td class="code"><div class="highlight"><pre><span></span>xbe name=integrator integrate=yes
# y = k int (x dt)
Jacobian: constant
input_vars: x
output_vars: y
aux_vars:
iparms:
sparms:
rparms: k=1
stparms: y_st=0
igparms: y_ig=0
outparms: x y
n_f= 1
f_1: d_dt(y)
n_g= 1
g_1: x
C:
prototypes:
variables:
source:
   if (G.flags[G.i_one_time_parms]) {
     return;
   }
   if (G.flags[G.i_init_guess]) {
     X.val_vr [nvr_y] = X.igprm[nig_y_ig];
     return;
   }
   if (G.flags[G.i_startup]) {
     if (G.flags[G.i_explicit]) {
       X.val_vr[nvr_y] = X.stprm[nst_y_st];
     } else if (G.flags[G.i_implicit]) {
       X.h[nf_1] = X.val_vr[nvr_y] - X.stprm[nst_y_st];
     }
     return;
   }
   if (G.flags[G.i_outvar]) {
     X.outprm[no_x] = X.val_vr[nvr_x];
     X.outprm[no_y] = X.val_vr[nvr_y];
     return;
   }
   if (G.flags[G.i_trns]) {
     if (G.flags[G.i_explicit]) {
       if (G.flags[G.i_alg_loop]) {
         X.h[nf_1] = X.val_vr[nvr_y] - X.val_vr_u[nvr_y];
       } else {
         k = X.rprm[nr_k];
         x = X.val_vr[nvr_x];
         X.f[nf_1] = k*x;
       }
     } else if (G.flags[G.i_implicit]) {
       k = X.rprm[nr_k];
       x = X.val_vr[nvr_x];
       if (G.flags[G.i_function]) {
         X.g[ng_1] = k*x;
       }
       if (G.flags[G.i_jacobian]) {
         J.dgdvr[ng_1][nvr_x] = k;
       }
     }
     return;
   }
endC
endxbe
</pre></div>
</td></tr></table></div>
<p>The structure of <code class="docutils literal notranslate"><span class="pre">integrator.xbe</span></code> is similar to that of
<a class="reference internal" href="#sum-2"><span class="std std-ref">sum_2.xbe</span></a>; here, we will only point out the
new features.</p>
<p>The start-up parameter <code class="docutils literal notranslate"><span class="pre">y_st</span></code> corresponds to <span class="math notranslate nohighlight">\(y_0\)</span>
mentioned above. The fact that time derivative of <code class="docutils literal notranslate"><span class="pre">y</span></code> is
involved in the element equation is indicated by the
<code class="docutils literal notranslate"><span class="pre">f_1</span></code> statement.</p>
<p>In the C++ part of the template,
we have different sections for start-up and transient simulation.
In the start-up section, the equation <span class="math notranslate nohighlight">\(y = y_0\)</span> is handled.
In the transient section, if the method is explicit, only the
function <span class="math notranslate nohighlight">\(f_1 = k\,x\)</span> is evaluated; if it is implicit,
the function <span class="math notranslate nohighlight">\(g_1 = k\,x\)</span> as well as its derivative
<span class="math notranslate nohighlight">\(\displaystyle\frac{\partial g_1}{\partial x}\)</span> are computed.</p>
</div>
<div class="section" id="indmc1-xbe">
<h3>indmc1.xbe<a class="headerlink" href="#indmc1-xbe" title="Permalink to this headline">¶</a></h3>
<p>We now look at a more complex element of type <code class="docutils literal notranslate"><span class="pre">integrate</span></code>,
viz., <code class="docutils literal notranslate"><span class="pre">indmc1.xbe</span></code>, which implements the induction machine model
given by,</p>
<div class="math notranslate nohighlight" id="equation-eq-indmc-1">
<span class="eqno">(2)<a class="headerlink" href="#equation-eq-indmc-1" title="Permalink to this equation">¶</a></span>\[\displaystyle\frac{d{\psi}_{ds}}{dt} = v_{ds}-r_si_{ds},\]</div>
<div class="math notranslate nohighlight" id="equation-eq-indmc-2">
<span class="eqno">(3)<a class="headerlink" href="#equation-eq-indmc-2" title="Permalink to this equation">¶</a></span>\[\displaystyle\frac{d{\psi}_{qs}}{dt} = v_{qs}-r_si_{qs},\]</div>
<div class="math notranslate nohighlight" id="equation-eq-indmc-3">
<span class="eqno">(4)<a class="headerlink" href="#equation-eq-indmc-3" title="Permalink to this equation">¶</a></span>\[\displaystyle\frac{d{\psi}_{dr}}{dt} = -\,\frac{P}{2}\,\omega_ {rm}\psi _{qr}-r_ri_{dr},\]</div>
<div class="math notranslate nohighlight" id="equation-eq-indmc-4">
<span class="eqno">(5)<a class="headerlink" href="#equation-eq-indmc-4" title="Permalink to this equation">¶</a></span>\[\displaystyle\frac{d{\psi}_{qr}}{dt} =  \frac{P}{2}\,\omega_ {rm}\psi _{dr}-r_ri_{qr},\]</div>
<div class="math notranslate nohighlight" id="equation-eq-indmc-5">
<span class="eqno">(6)<a class="headerlink" href="#equation-eq-indmc-5" title="Permalink to this equation">¶</a></span>\[\displaystyle\frac{d{\omega}_{rm}}{dt} = \frac{1}{J}\,(T_{em}-T_L),\]</div>
<p>where</p>
<div class="math notranslate nohighlight" id="equation-eq-indmc1-1">
<span class="eqno">(7)<a class="headerlink" href="#equation-eq-indmc1-1" title="Permalink to this equation">¶</a></span>\[i_{ds} = \frac{L_r}{L_m L_e}\,\psi _{ds} - \frac{1}{L_e}\,\psi _{dr},\]</div>
<div class="math notranslate nohighlight" id="equation-eq-indmc1-2">
<span class="eqno">(8)<a class="headerlink" href="#equation-eq-indmc1-2" title="Permalink to this equation">¶</a></span>\[i_{qs} = \frac{L_r}{L_m L_e}\,\psi _{qs} - \frac{1}{L_e}\,\psi _{qr},\]</div>
<div class="math notranslate nohighlight" id="equation-eq-indmc1-3">
<span class="eqno">(9)<a class="headerlink" href="#equation-eq-indmc1-3" title="Permalink to this equation">¶</a></span>\[i_{dr} = \frac{1}{L_m}\,\psi _{ds} - \left(\frac{L_{ls}}{L_m}+1\right)~i _{ds},\]</div>
<div class="math notranslate nohighlight" id="equation-eq-indmc1-4">
<span class="eqno">(10)<a class="headerlink" href="#equation-eq-indmc1-4" title="Permalink to this equation">¶</a></span>\[i_{qr} = \frac{1}{L_m}\,\psi _{qs} - \left(\frac{L_{ls}}{L_m}+1\right)~i _{qs},\]</div>
<div class="math notranslate nohighlight" id="equation-eq-indmc1-5">
<span class="eqno">(11)<a class="headerlink" href="#equation-eq-indmc1-5" title="Permalink to this equation">¶</a></span>\[T_{em} = \frac{3}{4}\, P L_m\,(i_{qs}i_{dr} - i_{ds}i_{qr}),\]</div>
<p>with</p>
<div class="math notranslate nohighlight" id="equation-eq-indmc2-1">
<span class="eqno">(12)<a class="headerlink" href="#equation-eq-indmc2-1" title="Permalink to this equation">¶</a></span>\[L_e = \displaystyle\frac{L_sL_r}{L_m}-L_m`,\]</div>
<div class="math notranslate nohighlight" id="equation-eq-indmc2-2">
<span class="eqno">(13)<a class="headerlink" href="#equation-eq-indmc2-2" title="Permalink to this equation">¶</a></span>\[L_s = L_{ls}+L_m`,\]</div>
<div class="math notranslate nohighlight" id="equation-eq-indmc2-3">
<span class="eqno">(14)<a class="headerlink" href="#equation-eq-indmc2-3" title="Permalink to this equation">¶</a></span>\[L_r = L_{lr}+L_m`.\]</div>
<p>Since the <code class="docutils literal notranslate"><span class="pre">indmc.xbe</span></code> template is rather long, we will split
it into several pieces for the purpose of discussion. The complete
template can be found in <code class="docutils literal notranslate"><span class="pre">~/gseim_grc/gseim/xbe/</span></code>.</p>
<p>Here is the overall template, without the C++ part:</p>
<div class="highlight-text notranslate" id="indmc1"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57</pre></div></td><td class="code"><div class="highlight"><pre><span></span>xbe name=indmc1 integrate=yes
# induction motor model
Jacobian: variable
input_vars: vqs vds tl
output_vars: wrm
aux_vars:
+  psids psidr psiqs psiqr
iparms:
+  poles=4
sparms:
rparms:
+  rs=0.435
+  lls=0.002
+  lm=0.0693
+  llr=0.002
+  rr=0.816
+  j=0.089
+  ls=0
+  lr=0
+  le=0
+  l1=0
+  l2=0
+  l3=0
+  x1=0
+  x2=0
stparms:
+  psids0=0
+  psiqs0=0
+  psidr0=0
+  psiqr0=0
+  wrm0=0
igparms:
outparms:
+  wrm
+  tem
+  vds
+  vqs
+  ia
+  ib
+  ic
n_f= 5
f_1: d_dt(psids)
f_2: d_dt(psiqs)
f_3: d_dt(psidr)
f_4: d_dt(psiqr)
f_5: d_dt(wrm)
n_g= 5
g_1: vds psids psidr
g_2: vqs psiqs psiqr
g_3: wrm psiqr psids psidr
g_4: wrm psidr psiqs psiqr
g_5: tl psids psidr psiqs psiqr
C:
....
....
endC
endxbe
</pre></div>
</td></tr></table></div>
<p>The input variables are
<code class="docutils literal notranslate"><span class="pre">vqs</span></code>, <code class="docutils literal notranslate"><span class="pre">vds</span></code>, <code class="docutils literal notranslate"><span class="pre">tl</span></code>, and the output variable is <code class="docutils literal notranslate"><span class="pre">wrm</span></code>.
In addition, it has internal (auxiliary) variables
<code class="docutils literal notranslate"><span class="pre">psi_ds</span></code>,
<code class="docutils literal notranslate"><span class="pre">psi_dr</span></code>,
<code class="docutils literal notranslate"><span class="pre">psi_qs</span></code>,
<code class="docutils literal notranslate"><span class="pre">psi_qr</span></code>
which are involved in the model equations.
The statements <code class="docutils literal notranslate"><span class="pre">f_1</span></code>, <code class="docutils literal notranslate"><span class="pre">f_2</span></code>, etc.
are used to inform the simulator which derivative is involved in that equation.
The statements <code class="docutils literal notranslate"><span class="pre">g_1</span></code>, <code class="docutils literal notranslate"><span class="pre">g_2</span></code>, etc.
are used to indicate which variables are involved in the right-hand
side of the corresponding equation.</p>
<p>In the induction machine equations,
there are some <em>one-time</em> calculations, e.g., calculation of <span class="math notranslate nohighlight">\(L_e\)</span>
(Eq. <a class="reference internal" href="#equation-eq-indmc2-1">(12)</a>),
which are not required to be performed in every time step. GSEIM provides
a flag for this purpose, as seen from in the following C++ section of the
template.</p>
<div class="highlight-text notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31</pre></div></td><td class="code"><div class="highlight"><pre><span></span>if (G.flags[G.i_one_time_parms]) {
  k4 = 0.5*(sqrt(3.0));

  lls = X.rprm[nr_lls];
  lm  = X.rprm[nr_lm ];
  llr = X.rprm[nr_llr];

  ls = lls + lm;
  lr = llr + lm;
  le = (ls*lr/lm) - lm;
  l1 = lr/(lm*le);
  l2 = 1.0 + (lls/lm);
  l3 = lls/lm;

  X.rprm[nr_ls] = ls;
  X.rprm[nr_lr] = lr;
  X.rprm[nr_le] = le;
  X.rprm[nr_l1] = l1;
  X.rprm[nr_l2] = l2;
  X.rprm[nr_l3] = l3;

  poles = X.iprm[ni_poles];
  p = (double)(poles);
  x1 = 0.75*p*lm;
  x2 = 0.5*p;

  X.rprm[nr_x1] = x1;
  X.rprm[nr_x2] = x2;

  return;
}
</pre></div>
</td></tr></table></div>
<p>When this flag is
set by the main program, the template computes <span class="math notranslate nohighlight">\(L_e\)</span> and other one-time
parameters, and saves them in the <code class="docutils literal notranslate"><span class="pre">X.rprm</span></code> vector. These
parameters need not be computed again during simulation.</p>
<p>Next, we look at the function assignment sections of <code class="docutils literal notranslate"><span class="pre">indmc1.xbe</span></code>:</p>
<div class="highlight-text notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148</pre></div></td><td class="code"><div class="highlight"><pre><span></span>if (G.flags[G.i_trns]) {
  if (G.flags[G.i_explicit]) {
    if (G.flags[G.i_alg_loop]) {
      X.h[nf_1] = X.val_aux[na_psids] - X.val_aux_u[na_psids];
      X.h[nf_2] = X.val_aux[na_psiqs] - X.val_aux_u[na_psiqs];
      X.h[nf_3] = X.val_aux[na_psidr] - X.val_aux_u[na_psidr];
      X.h[nf_4] = X.val_aux[na_psiqr] - X.val_aux_u[na_psiqr];
      X.h[nf_5] = X.val_vr [nvr_wrm ] - X.val_vr_u [nvr_wrm ];
    } else {
      rs  = X.rprm[nr_rs ];
      lls = X.rprm[nr_lls];
      lm  = X.rprm[nr_lm ];
      rr  = X.rprm[nr_rr ];
      j   = X.rprm[nr_j  ];
      le  = X.rprm[nr_le ];
      l1  = X.rprm[nr_l1 ];
      l2  = X.rprm[nr_l2 ];
      l3  = X.rprm[nr_l3 ];
      x1  = X.rprm[nr_x1 ];
      x2  = X.rprm[nr_x2 ];

      vqs = X.val_vr[nvr_vqs];
      vds = X.val_vr[nvr_vds];
      wrm = X.val_vr[nvr_wrm];
      tl  = X.val_vr[nvr_tl ];

      psids = X.val_aux[na_psids];
      psidr = X.val_aux[na_psidr];
      psiqs = X.val_aux[na_psiqs];
      psiqr = X.val_aux[na_psiqr];

      ids = (l1*psids) - (psidr/le);
      iqs = (l1*psiqs) - (psiqr/le);

      idr = (psids/lm) - (l2*ids);
      iqr = (psiqs/lm) - (l2*iqs);

      tem0 = x1*(iqs*idr-ids*iqr);
      wr   = x2*wrm;

      X.f[nf_1] = vds-rs*ids;
      X.f[nf_2] = vqs-rs*iqs;
      X.f[nf_3] = (-wr)*psiqr-rr*idr;
      X.f[nf_4] = ( wr)*psidr-rr*iqr;
      X.f[nf_5] = (tem0-tl)/j;
    }
  } else {
    rs  = X.rprm[nr_rs ];
    lls = X.rprm[nr_lls];
    lm  = X.rprm[nr_lm ];
    rr  = X.rprm[nr_rr ];
    j   = X.rprm[nr_j  ];
    le  = X.rprm[nr_le ];
    l1  = X.rprm[nr_l1 ];
    l2  = X.rprm[nr_l2 ];
    l3  = X.rprm[nr_l3 ];
    x1  = X.rprm[nr_x1 ];
    x2  = X.rprm[nr_x2 ];

    vqs = X.val_vr[nvr_vqs];
    vds = X.val_vr[nvr_vds];
    wrm = X.val_vr[nvr_wrm];
    tl  = X.val_vr[nvr_tl ];

    psids = X.val_aux[na_psids];
    psidr = X.val_aux[na_psidr];
    psiqs = X.val_aux[na_psiqs];
    psiqr = X.val_aux[na_psiqr];

    if (G.flags[G.i_function] || G.flags[G.i_jacobian]) {
      ids = (l1*psids) - (psidr/le);
      iqs = (l1*psiqs) - (psiqr/le);
      idr = (psids/lm) - (l2*ids);
      iqr = (psiqs/lm) - (l2*iqs);
      tem0 = x1*(iqs*idr-ids*iqr);
      wr = x2*wrm;

      if (G.flags[G.i_function]) {
        X.g[ng_1] = vds-rs*ids;
        X.g[ng_2] = vqs-rs*iqs;
        X.g[ng_3] = (-wr)*psiqr-rr*idr;
        X.g[ng_4] = ( wr)*psidr-rr*iqr;
        X.g[ng_5] = (tem0-tl)/j;
      }
    }
    if (G.flags[G.i_jacobian]) {
      ids_psids = l1;
      ids_psidr = -1.0/le;

      iqs_psiqs = l1;
      iqs_psiqr = -1.0/le;

      idr_psids = (1.0/lm) - (l2*ids_psids);
      idr_psidr =          - (l2*ids_psidr);

      iqr_psiqs = (1.0/lm) - (l2*iqs_psiqs);
      iqr_psiqr =          - (l2*iqs_psiqr);

      tem0_iqs =  x1*idr;
      tem0_idr =  x1*iqs;
      tem0_ids = -x1*iqr;
      tem0_iqr = -x1*ids;

      tem0_psids =
        tem0_idr*idr_psids +
        tem0_ids*ids_psids;

      tem0_psidr =
        tem0_idr*idr_psidr +
        tem0_ids*ids_psidr;

      tem0_psiqs =
        tem0_iqs*iqs_psiqs +
        tem0_iqr*iqr_psiqs;

      tem0_psiqr =
        tem0_iqs*iqs_psiqr +
        tem0_iqr*iqr_psiqr;

      wr_wrm = x2;

      J.dgdvr[ng_1][nvr_vds] = 1.0;
      J.dgdaux[ng_1][na_psids] = -rs*ids_psids;
      J.dgdaux[ng_1][na_psidr] = -rs*ids_psidr;

      J.dgdvr[ng_2][nvr_vqs] = 1.0;
      J.dgdaux[ng_2][na_psiqs] = -rs*iqs_psiqs;
      J.dgdaux[ng_2][na_psiqr] = -rs*iqs_psiqr;

      J.dgdvr[ng_3][nvr_wrm] = (-wr_wrm)*psiqr;
      J.dgdaux[ng_3][na_psiqr] = (-wr);
      J.dgdaux[ng_3][na_psids] = -rr*idr_psids;
      J.dgdaux[ng_3][na_psidr] = -rr*idr_psidr;

      J.dgdvr[ng_4][nvr_wrm] = (wr_wrm)*psidr;
      J.dgdaux[ng_4][na_psidr] = wr;
      J.dgdaux[ng_4][na_psiqs] = -rr*iqr_psiqs;
      J.dgdaux[ng_4][na_psiqr] = -rr*iqr_psiqr;

      J.dgdvr[ng_5][nvr_tl] = -1.0/j;
      J.dgdaux[ng_5][na_psids] = tem0_psids/j;
      J.dgdaux[ng_5][na_psidr] = tem0_psidr/j;
      J.dgdaux[ng_5][na_psiqs] = tem0_psiqs/j;
      J.dgdaux[ng_5][na_psiqr] = tem0_psiqr/j;
    }
  }
  return;
}
</pre></div>
</td></tr></table></div>
<p>In the explicit case,
the function <span class="math notranslate nohighlight">\(f_1\)</span> (i.e.,
<code class="docutils literal notranslate"><span class="pre">X.f[nf_1]</span></code>) is computed as per the right-hand side of
Eq. <a class="reference internal" href="#equation-eq-indmc-1">(2)</a>, and so on.
In the implicit case,
the function <span class="math notranslate nohighlight">\(g_1\)</span> is computed in a similar manner. Note that,
in this case, the derivatives of <span class="math notranslate nohighlight">\(g_1\)</span> with respect to each of the variables involved
in that equation are also computed.</p>
<p>The output parameter computation section of the template is
given below:</p>
<div class="highlight-text notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30</pre></div></td><td class="code"><div class="highlight"><pre><span></span>if (G.flags[G.i_outvar]) {
  X.outprm[no_wrm] = X.val_vr[nvr_wrm];
  X.outprm[no_vds] = X.val_vr[nvr_vds];
  X.outprm[no_vqs] = X.val_vr[nvr_vqs];

  psids = X.val_aux[na_psids];
  psidr = X.val_aux[na_psidr];
  psiqs = X.val_aux[na_psiqs];
  psiqr = X.val_aux[na_psiqr];

  le  = X.rprm[nr_le];
  lm  = X.rprm[nr_lm];
  l1  = X.rprm[nr_l1];
  l2  = X.rprm[nr_l2];

  ids = (l1*psids) - (psidr/le);
  iqs = (l1*psiqs) - (psiqr/le);
  idr = (psids/lm) - (l2*ids);
  iqr = (psiqs/lm) - (l2*iqs);

  X.outprm[no_ia] = iqs;
  X.outprm[no_ib] = -0.5*iqs-k4*ids;
  X.outprm[no_ic] = -0.5*iqs+k4*ids;

  x1 = X.rprm[nr_x1];
  tem0 = x1*(iqs*idr-ids*iqr);
  X.outprm[no_tem] = tem0;

  return;
}
</pre></div>
</td></tr></table></div>
<p>For <a class="reference internal" href="#indmc1"><span class="std std-ref">indmc1.xbe</span></a>, the output parameter are
<code class="docutils literal notranslate"><span class="pre">wrm</span></code>, <code class="docutils literal notranslate"><span class="pre">tem</span></code>, <code class="docutils literal notranslate"><span class="pre">vds</span></code>, <code class="docutils literal notranslate"><span class="pre">vqs</span></code>, <code class="docutils literal notranslate"><span class="pre">ia</span></code>, <code class="docutils literal notranslate"><span class="pre">ib</span></code>, <code class="docutils literal notranslate"><span class="pre">ic</span></code>.
To assign the current value of the <em>variable</em> <code class="docutils literal notranslate"><span class="pre">wrm</span></code> to the
<em>output parameter</em> <code class="docutils literal notranslate"><span class="pre">wrm</span></code>, we need to assign
<code class="docutils literal notranslate"><span class="pre">X.outprm[no_wrm]</span></code>, and so on. Note that
<code class="docutils literal notranslate"><span class="pre">ia</span></code>, <code class="docutils literal notranslate"><span class="pre">ib</span></code>, <code class="docutils literal notranslate"><span class="pre">ic</span></code>, <code class="docutils literal notranslate"><span class="pre">tem</span></code> are not readily available (they
are not input, output, or auxiliary variables of this template),
and therefore need to be computed and then assigned.</p>
</div>
</div>
<div class="section" id="xbe-f-g-h-functions">
<span id="xbe-fgh"></span><h2>xbe: f, g, h functions<a class="headerlink" href="#xbe-f-g-h-functions" title="Permalink to this headline">¶</a></h2>
<p>An attractive feature offered by GSEIM is the facility for
the user to make up a new element (<code class="docutils literal notranslate"><span class="pre">xbe</span></code>). In order to
use this facility effectively, it is important to understand
the working of explicit and implicit methods for solving ODEs
(see <a class="reference internal" href="numerical.html#numerical"><span class="std std-ref">Numerical methods for ODEs</span></a>).</p>
<p id="trns"><strong>Transient simulation:</strong>
Here, we will take two
representative methods, Forward Euler (FE) and Backward Euler (BE),
and explain what information about the ODEs needs to be provided
by the <code class="docutils literal notranslate"><span class="pre">xbe</span></code> template in each case. The FE method has its limitations
in terms of accuracy and stability and is therefore rarely used.
However, for the purpose of this discussion, it is adequate.
For simplicity, we consider a single ODE of the form,</p>
<div class="math notranslate nohighlight" id="equation-eq-ode-1">
<span class="eqno">(15)<a class="headerlink" href="#equation-eq-ode-1" title="Permalink to this equation">¶</a></span>\[\displaystyle\frac{dx_k}{dt} = u(x_1,\,x_2,\cdots,\,t).\]</div>
<p>The discretised forms of Eq. <a class="reference internal" href="#equation-eq-ode-1">(15)</a> obtained with the
FE and BE methods are given by</p>
<div class="math notranslate nohighlight" id="equation-eq-fe-1">
<span class="eqno">(16)<a class="headerlink" href="#equation-eq-fe-1" title="Permalink to this equation">¶</a></span>\[FE:~x_k^{n+1} = x_k^n + h\,u(x_1^n,\,x_2^n,\cdots,\,t_n),\]</div>
<div class="math notranslate nohighlight" id="equation-eq-be-1">
<span class="eqno">(17)<a class="headerlink" href="#equation-eq-be-1" title="Permalink to this equation">¶</a></span>\[BE:~x_k^{n+1} = x_k^n + h\,u(x_1^{n+1},\,x_2^{n+1},\cdots,\,t_{n+1}),\]</div>
<p>where <span class="math notranslate nohighlight">\(x_i^n\)</span> is the numerical solution at time <span class="math notranslate nohighlight">\(t_n\)</span>.
There is a striking difference between these two forms: The right-hand side
involves
<em>known</em> quantities
<span class="math notranslate nohighlight">\((x_1^n,\,x_2^n,\cdots)\)</span>
in the FE formula, and
<em>unknown</em> quantities
<span class="math notranslate nohighlight">\((x_1^{n+1},\,x_2^{n+1},\cdots)\)</span>
in the BE formula.
This implies that, to obtain <span class="math notranslate nohighlight">\(x_k^{n+1}\)</span>, we only need to
<em>evaluate</em> the right-hand side of <a class="reference internal" href="#equation-eq-fe-1">(16)</a> for the FE method,
but <em>solve</em> <a class="reference internal" href="#equation-eq-be-1">(17)</a> for the BE method.</p>
<p>Assuming that <span class="math notranslate nohighlight">\(u(x_1,\,x_2,\cdots)\)</span> is in general a nonlinear
function, the <a class="reference internal" href="nr.html#nr"><span class="std std-ref">Newton-Raphson method</span></a>
is used in GSEIM to solve <a class="reference internal" href="#equation-eq-be-1">(17)</a>, requiring the function value <span class="math notranslate nohighlight">\(u\)</span>
as well as the derivative (Jacobian) values
<span class="math notranslate nohighlight">\(\displaystyle\frac{\partial u}{\partial x_1}, \displaystyle\frac{\partial u}{\partial x_2}, \cdots\)</span>.
This brings us to the following requirement from an <code class="docutils literal notranslate"><span class="pre">xbe</span></code> template of
<code class="docutils literal notranslate"><span class="pre">integrate</span></code> type.</p>
<p><strong>Transient simulation with explicit methods:</strong> Supply
<span class="math notranslate nohighlight">\(u(x_1,\,x_2,\cdots,\,t)\)</span>. The function <span class="math notranslate nohighlight">\(u\)</span> in <a class="reference internal" href="#equation-eq-ode-1">(15)</a>
is denoted by <code class="docutils literal notranslate"><span class="pre">f</span></code> in GSEIM terminology.</p>
<p><strong>Transient simulation with implicit methods:</strong> Supply
<span class="math notranslate nohighlight">\(u(x_1,\,x_2,\cdots,\,t)\)</span> as well as
<span class="math notranslate nohighlight">\(\displaystyle\frac{\partial u}{\partial x_1}, \displaystyle\frac{\partial u}{\partial x_2}, \cdots\)</span>.
These are denoted by <code class="docutils literal notranslate"><span class="pre">g</span></code>, <code class="docutils literal notranslate"><span class="pre">dgdx</span></code> in GSEIM terminology.</p>
<p>Note that, since there are multiple ODEs in general in an <code class="docutils literal notranslate"><span class="pre">integrate</span></code> type
<code class="docutils literal notranslate"><span class="pre">xbe</span></code> template, <code class="docutils literal notranslate"><span class="pre">f</span></code>, <code class="docutils literal notranslate"><span class="pre">g</span></code> are one-dimensional vectors, and <code class="docutils literal notranslate"><span class="pre">dgdx</span></code> is a
two-dimensional vector.</p>
<p>In <code class="docutils literal notranslate"><span class="pre">xbe</span></code>’s of type <code class="docutils literal notranslate"><span class="pre">evaluate</span></code>, the equations are of the form,</p>
<div class="math notranslate nohighlight" id="equation-eq-eval-1">
<span class="eqno">(18)<a class="headerlink" href="#equation-eq-eval-1" title="Permalink to this equation">¶</a></span>\[y = u(x_1,\,x_2,\cdots,\,t),\]</div>
<p>where
<span class="math notranslate nohighlight">\(x_1\)</span>,
<span class="math notranslate nohighlight">\(x_2\)</span>,
<span class="math notranslate nohighlight">\(\cdots\)</span>
are the input variables, and
<span class="math notranslate nohighlight">\(y\)</span>
is the output variable.
If an explicit method is being used, GSEIM expects
the <code class="docutils literal notranslate"><span class="pre">xbe</span></code> template to return
<span class="math notranslate nohighlight">\(y\)</span>.
If an implicit method is being used, GSEIM expects
information about a function
<span class="math notranslate nohighlight">\(v\)</span>, defined as</p>
<div class="math notranslate nohighlight" id="equation-eq-eval-2">
<span class="eqno">(19)<a class="headerlink" href="#equation-eq-eval-2" title="Permalink to this equation">¶</a></span>\[v \equiv y - u(x_1,\,x_2,\cdots,\,t).\]</div>
<p>In this case, the <code class="docutils literal notranslate"><span class="pre">xbe</span></code> template is expected to return
<span class="math notranslate nohighlight">\(v\)</span> and its derivatives with respect to the variables
involved in that equation. The variables to be assigned in
the <code class="docutils literal notranslate"><span class="pre">xbe</span></code> template are the vectors <code class="docutils literal notranslate"><span class="pre">g</span></code> and <code class="docutils literal notranslate"><span class="pre">dgdx</span></code>.</p>
<p id="startup-1"><strong>Start-up simulation:</strong>
In some situations, it is required to assign specific values
to the state variables in the system (such as <span class="math notranslate nohighlight">\(x_k\)</span> in
<a class="reference internal" href="#equation-eq-ode-1">(15)</a>), and solve for the remaining variables. We will
refer to this type of simulation as <a class="reference internal" href="startup.html#startup"><span class="std std-ref">Start-up simulation</span></a>.</p>
<p><a class="reference internal" href="#equation-eq-ode-1">(15)</a> in the start-up scenario is written as</p>
<div class="math notranslate nohighlight" id="equation-eq-strtup-1">
<span class="eqno">(20)<a class="headerlink" href="#equation-eq-strtup-1" title="Permalink to this equation">¶</a></span>\[x_k = x_k^{st},\]</div>
<p>where <span class="math notranslate nohighlight">\(x_k = x_k^{st}\)</span> is the start-up value. If an explicit
method is being used, the <code class="docutils literal notranslate"><span class="pre">xbe</span></code> template simply needs to make the
above assignment. If an implicit method is being used, <a class="reference internal" href="#equation-eq-strtup-1">(20)</a>
needs to be rewritten as</p>
<div class="math notranslate nohighlight" id="equation-eq-strtup-2">
<span class="eqno">(21)<a class="headerlink" href="#equation-eq-strtup-2" title="Permalink to this equation">¶</a></span>\[w \equiv x_k - x_k^{st} = 0,\]</div>
<p>and <span class="math notranslate nohighlight">\(w\)</span> needs to be returned by the <code class="docutils literal notranslate"><span class="pre">xbe</span></code> template (in the form
of vector <code class="docutils literal notranslate"><span class="pre">h</span></code>).</p>
<p>For <code class="docutils literal notranslate"><span class="pre">evaluate</span></code> type elements, the start-up situation can be handled in
the same manner as the transient situation.</p>
<p><strong>Algebraic loops:</strong>
The <em>flow-graph</em> approach, with each element having input and output ports,
runs into problems if there are <a class="reference internal" href="numerical.html#alg-loops"><span class="std std-ref">Algebraic loops</span></a> in the system. For example,
consider the following system.</p>
<a class="reference internal image-reference" href="_images/alg_loop_1.png"><img alt="algebraic loop" src="_images/alg_loop_1.png" style="width: 320px;" /></a>
<p>In this system, there are no time derivatives. It is therefore sufficient to
consider any time <span class="math notranslate nohighlight">\(t_n\)</span> and see if we can obtain
<span class="math notranslate nohighlight">\(x_2^n\)</span>,
<span class="math notranslate nohighlight">\(x_3^n\)</span>,
<span class="math notranslate nohighlight">\(x_4^n\)</span>
in terms of the input
<span class="math notranslate nohighlight">\(x_1^n\)</span>.
The following equations must be satisfied:</p>
<div class="math notranslate nohighlight" id="equation-eq-alg-1">
<span class="eqno">(22)<a class="headerlink" href="#equation-eq-alg-1" title="Permalink to this equation">¶</a></span>\[x_2^n = x_1^n - x_4^n,\]</div>
<div class="math notranslate nohighlight" id="equation-eq-alg-2">
<span class="eqno">(23)<a class="headerlink" href="#equation-eq-alg-2" title="Permalink to this equation">¶</a></span>\[x_4^n = k_2 x_3^n,\]</div>
<div class="math notranslate nohighlight" id="equation-eq-alg-3">
<span class="eqno">(24)<a class="headerlink" href="#equation-eq-alg-3" title="Permalink to this equation">¶</a></span>\[x_3^n = k_1 x_2^n.\]</div>
<p>In an explicit method, we treat <span class="math notranslate nohighlight">\(x_1^n\)</span> as the
source, and then compute variables one by one, following
the arrows in the figure, by evaluating Eqs.
<a class="reference internal" href="#equation-eq-alg-1">(22)</a> to
<a class="reference internal" href="#equation-eq-alg-3">(24)</a>
in succession. This approach leads to a problem: The three
equations are supposed to be valid <em>simultaneously</em>. However, since
<a class="reference internal" href="#equation-eq-alg-3">(24)</a> is evaluated <em>after</em>
<a class="reference internal" href="#equation-eq-alg-2">(23)</a>, the value of
<span class="math notranslate nohighlight">\(x_3^n\)</span> is not consistently computed.
This type of conflict occurs when there is an <em>algebraic loop</em>
in the system, i.e., there is a loop in which the variables are
related through purely {it algebraic} equations, not involving
time derivatives.</p>
<p>If an implicit method is used for the above system, Eqs.
<a class="reference internal" href="#equation-eq-alg-1">(22)</a> to
<a class="reference internal" href="#equation-eq-alg-3">(24)</a>
are solved simultaneously (as an algebraic system of equations),
and there is no conflict.</p>
<p>Now consider applying an explicit method to a system which has
both <code class="docutils literal notranslate"><span class="pre">integrate</span></code> type elements (involving time derivatives)
and <code class="docutils literal notranslate"><span class="pre">evaluate</span></code> type elements. If there is an algebraic loop
in the system, a consistent solution can be obtained in two steps:</p>
<ol class="arabic simple">
<li>Update the outputs of <code class="docutils literal notranslate"><span class="pre">integrate</span></code> type elements.</li>
<li>Solve the algebraic system of equations involving the remaining
variables using a suitable method (GSEIM uses the
<a class="reference external" href="https://www.ee.iitb.ac.in/~sequel/sequel_manual_1.pdf">Newton-Raphson method</a>.</li>
</ol>
<p>The second step is implemented in GSEIM by holding the updated output
values of <code class="docutils literal notranslate"><span class="pre">integrate</span></code> type elements (denoted by <span class="math notranslate nohighlight">\(x^u\)</span>)
constant, and solving the resulting algebraic set of equations.
In other words, for <code class="docutils literal notranslate"><span class="pre">integrate</span></code> time elements, we need to replace
the original equation</p>
<div class="math notranslate nohighlight">
\[\displaystyle\frac{dx_k}{dt} = u(x_1,\,x_2,\cdots,\,t).\]</div>
<p>with</p>
<div class="math notranslate nohighlight">
\[x_k - x_k^u = 0,\]</div>
<p>and the <code class="docutils literal notranslate"><span class="pre">xbe</span></code> template in this situation should return
<span class="math notranslate nohighlight">\(h \equiv x_k - x_k^u\)</span>.</p>
<p><strong>Summary:</strong>
The above points regarding xbe templates can be summarised as follows.</p>
<a class="reference internal image-reference" href="_images/xbe_trns.png"><img alt="xbe transient functions" src="_images/xbe_trns.png" style="width: 620px;" /></a>
<div class="line-block">
<div class="line"><br /></div>
</div>
<a class="reference internal image-reference" href="_images/xbe_startup.png"><img alt="xbe startup functions" src="_images/xbe_startup.png" style="width: 480px;" /></a>
</div>
<div class="section" id="ebe-templates">
<h2>ebe templates<a class="headerlink" href="#ebe-templates" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Template files for electrical type elements have extension
<code class="docutils literal notranslate"><span class="pre">.ebe</span></code> (<em>electrical basic element</em>), and they are located in
directory <code class="docutils literal notranslate"><span class="pre">$EBE</span></code> (see <a class="reference internal" href="organisation.html#gseimorg"><span class="std std-ref">GSEIM Organisation</span></a>).</li>
<li>An electrical element template has nodes (which are used in
wiring) and some other variables in general:<ul>
<li>state variables which may be used in elements whose equations
involve time derivatives</li>
<li>auxiliary variables which serve as additional variables to be
used in implementing the element equations</li>
</ul>
</li>
</ul>
<p>In the following, we look at a few representative examples
to explain the functioning of the <code class="docutils literal notranslate"><span class="pre">ebe</span></code> templates. The
templates described here can be found in <code class="docutils literal notranslate"><span class="pre">$EBE</span></code>.</p>
<div class="section" id="r-ebe">
<span id="resistor"></span><h3>r.ebe<a class="headerlink" href="#r-ebe" title="Permalink to this headline">¶</a></h3>
<p>This is the resistor element with nodes <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">n</span></code>, and
resistance <code class="docutils literal notranslate"><span class="pre">r</span></code>. The template <code class="docutils literal notranslate"><span class="pre">r.ebe</span></code> is reproduced below.</p>
<div class="highlight-text notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91</pre></div></td><td class="code"><div class="highlight"><pre><span></span>ebe name=r
Jacobian: constant
nodes: p n
state_vars:
aux_vars:
aux_vars_startup:
x_vars:
iparms:
sparms:
rparms:
+  r=1.0
+  k_scale=1
+  g=0
stparms:
igparms:
outparms: i v
n_f=2
f_1: v(p) v(n)
f_2: v(p) v(n)
n_g=0
n_h=2
h_1: v(p) v(n)
h_2: v(p) v(n)
C:
variables:
   double vp,vn,r_eff;
source:
   if (G.flags[G.i_one_time_parms]) {
     r = X.rprm[nr_r];
     k_scale = X.rprm[nr_k_scale];
     if (r*k_scale &lt; 1.0e-9) {
       cout &lt;&lt; &quot;r.ebe: r too small!&quot; &lt;&lt; endl;
       cout &lt;&lt; &quot;r.ebe: r=&quot; &lt;&lt; r &lt;&lt; endl;
       cout &lt;&lt; &quot;r.ebe: k_scale=&quot; &lt;&lt; k_scale &lt;&lt; endl;
       exit(1);
     }
     r_eff = r*k_scale;

     g = 1.0e0/r_eff;
     X.rprm[nr_g] = g;
     return;
   }
   if (G.flags[G.i_dc] || G.flags[G.i_trns]) {
     vp = X.val_nd[nnd_p];
     vn = X.val_nd[nnd_n];

     g = X.rprm[nr_g];

     if (G.flags[G.i_function]) {
       X.f[nf_1] = g*(vp-vn);
       X.f[nf_2] = -X.f[nf_1];
     }
     if (G.flags[G.i_jacobian]) {
       J.dfdv[nf_1][nnd_p] =  g;
       J.dfdv[nf_1][nnd_n] = -g;
       J.dfdv[nf_2][nnd_p] = -g;
       J.dfdv[nf_2][nnd_n] =  g;
     }
     return;
   }
   if (G.flags[G.i_startup]) {
     vp = X.val_nd[nnd_p];
     vn = X.val_nd[nnd_n];

     g = X.rprm[nr_g];

     if (G.flags[G.i_function]) {
       X.h[nh_1] = g*(vp-vn);
       X.h[nh_2] = -X.f[nf_1];
     }
     if (G.flags[G.i_jacobian]) {
       J.dhdv[nh_1][nnd_p] =  g;
       J.dhdv[nh_1][nnd_n] = -g;
       J.dhdv[nh_2][nnd_p] = -g;
       J.dhdv[nh_2][nnd_n] =  g;
     }
     return;
   }
   if (G.flags[G.i_outvar]) {
     g = X.rprm[nr_g];
     X.outprm[no_v] = X.val_nd[nnd_p]-X.val_nd[nnd_n];
     X.outprm[no_i] = g*(X.val_nd[nnd_p]-X.val_nd[nnd_n]);
     return;
   }
   if (G.flags[G.i_init_guess]) {
     X.val_nd[nnd_n] = 0.0;
     X.val_nd[nnd_p] = 0.0;
     return;
   }
endC
endebe
</pre></div>
</td></tr></table></div>
<p>There are several common aspects between <code class="docutils literal notranslate"><span class="pre">xbe</span></code> templates
and <code class="docutils literal notranslate"><span class="pre">ebe</span></code> templates. Here, we will point out mainly features
which are different for <code class="docutils literal notranslate"><span class="pre">ebe</span></code> templates:</p>
<ul class="simple">
<li>The element name is specified by the keyword <code class="docutils literal notranslate"><span class="pre">name</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">Jacobian:</span> <span class="pre">constant</span></code> indicates that
the element equations have constant derivatives with respect
to the variables involved in those equations.</li>
<li>The <code class="docutils literal notranslate"><span class="pre">state_vars</span></code> statement is used to list variables
related to time derivatives. Since the resistor element does
not involve time derivatives, there are no state_vars.</li>
<li>The <code class="docutils literal notranslate"><span class="pre">aux_vars</span></code> and <code class="docutils literal notranslate"><span class="pre">aux_vars_startup</span></code> statements are used
to list auxiliary variables used in implementing the element
equations in transient and start-up simulation, respectively.
For the resistor, they are not required.</li>
<li>The <code class="docutils literal notranslate"><span class="pre">x_vars</span></code> statement gives the flow-graph type nodes of
the element. The resistor has only electrical nodes, and the
x_vars list is empty.</li>
<li>In the real parameters (<code class="docutils literal notranslate"><span class="pre">rparms</span></code>) field, the resistance value
<code class="docutils literal notranslate"><span class="pre">r</span></code>, the scaling factor <code class="docutils literal notranslate"><span class="pre">k_scale</span></code>, and the conductance <code class="docutils literal notranslate"><span class="pre">g</span></code>
are listed. Of these, <code class="docutils literal notranslate"><span class="pre">r</span></code> and <code class="docutils literal notranslate"><span class="pre">k_scale</span></code> are supplied by the
user while <code class="docutils literal notranslate"><span class="pre">g</span></code> is assigned internally as a one-time calculation.</li>
<li>The <code class="docutils literal notranslate"><span class="pre">n_f</span></code>,``n_g``, <code class="docutils literal notranslate"><span class="pre">n_h</span></code> statements specify the number
of <code class="docutils literal notranslate"><span class="pre">f</span></code>, <code class="docutils literal notranslate"><span class="pre">g</span></code>, and <code class="docutils literal notranslate"><span class="pre">h</span></code> functions for this element.
(see <a class="reference internal" href="#ebe-fgh"><span class="std std-ref">ebe: f, g, h functions</span></a>.)</li>
<li>In the <code class="docutils literal notranslate"><span class="pre">C</span></code> part of the template, function and Jacobian values
are assigned. Note that electrical elements are always handled
with implicit methods.</li>
</ul>
<p>The equations for the resistor template are given by</p>
<div class="math notranslate nohighlight" id="equation-eq-r-1">
<span class="eqno">(25)<a class="headerlink" href="#equation-eq-r-1" title="Permalink to this equation">¶</a></span>\[i_p = g\, (v_p-v_n),\]</div>
<div class="math notranslate nohighlight" id="equation-eq-r-2">
<span class="eqno">(26)<a class="headerlink" href="#equation-eq-r-2" title="Permalink to this equation">¶</a></span>\[i_n = g\, (v_n-v_p),\]</div>
<p>where
<span class="math notranslate nohighlight">\(i_p\)</span> and
<span class="math notranslate nohighlight">\(i_n\)</span> are currents entering the resistor (from the external
circuit), and
<span class="math notranslate nohighlight">\(v_p\)</span> and
<span class="math notranslate nohighlight">\(v_n\)</span> are the node voltages, given by
<code class="docutils literal notranslate"><span class="pre">X.val_nd[nnd_p]</span></code> and
<code class="docutils literal notranslate"><span class="pre">X.val_nd[nnd_n]</span></code>, respectively.
Note that the functions
<code class="docutils literal notranslate"><span class="pre">X.f[nf_1]</span></code>,
<code class="docutils literal notranslate"><span class="pre">X.f[nf_2]</span></code>
correspond to
<span class="math notranslate nohighlight">\(i_p\)</span> and
<span class="math notranslate nohighlight">\(i_n\)</span>
in transient simulation, and
<code class="docutils literal notranslate"><span class="pre">X.h[nh_1]</span></code>,
<code class="docutils literal notranslate"><span class="pre">X.h[nh_2]</span></code>
correspond to the same currents in start-up simulation.</p>
</div>
<div class="section" id="diode-r-ebe">
<span id="diode-r"></span><h3>diode_r.ebe<a class="headerlink" href="#diode-r-ebe" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">diode_r</span></code> is a simple diode model, which behaves like
a resistance <code class="docutils literal notranslate"><span class="pre">r_off</span></code> when the diode is not conducting, and
a resistance <code class="docutils literal notranslate"><span class="pre">r_on</span></code> with a source <code class="docutils literal notranslate"><span class="pre">v_on</span></code> in series when
the diode is conducting (see the figure below).</p>
<a class="reference internal image-reference" href="_images/diode_r_model.png"><img alt="diode_r model" src="_images/diode_r_model.png" style="width: 200px;" /></a>
<p>If the diode is conducting, the element equations are given by</p>
<div class="math notranslate nohighlight" id="equation-neq-diode-r-on">
<span class="eqno">(27)<a class="headerlink" href="#equation-neq-diode-r-on" title="Permalink to this equation">¶</a></span>\[\begin{split}\begin{align}
i_p &amp;= \left(V_p-V_n-V_{\mathrm{on}}\right)/R_{\mathrm{on}}\,,\\
i_n &amp;= -i_p\,.
\end{align}\end{split}\]</div>
<p>If the diode is not conducting, the element equations are given by</p>
<div class="math notranslate nohighlight" id="equation-neq-diode-r-off">
<span class="eqno">(28)<a class="headerlink" href="#equation-neq-diode-r-off" title="Permalink to this equation">¶</a></span>\[\begin{split}\begin{align}
i_p &amp;= \left(V_p-V_n\right)/R_{\mathrm{off}}\,,\\
i_n &amp;= -i_p\,.
\end{align}\end{split}\]</div>
<p>Incorporation of the above equations can be clearly seen in <code class="docutils literal notranslate"><span class="pre">diode_r.ebe</span></code>,
reproduced below.</p>
<div class="highlight-text notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106</pre></div></td><td class="code"><div class="highlight"><pre><span></span>ebe name=diode_r
Jacobian: variable
nodes: p n
state_vars:
aux_vars:
aux_vars_startup:
x_vars:
iparms:
sparms:
rparms:
+  r_on=0.1
+  r_off=1M
+  v_on=0
+  v_on_1=0
stparms:
igparms:
outparms: i v
n_f=2
f_1: v(p) v(n)
f_2: v(p) v(n)
n_g=0
n_h=2
h_1: v(p) v(n)
h_2: v(p) v(n)
C:
variables:
   double vp,vn,r,g,v0;
source:
   if (G.flags[G.i_one_time_parms]) {
     r_on  = X.rprm[nr_r_on ];
     r_off = X.rprm[nr_r_off];
     v_on  = X.rprm[nr_v_on ];

     v_on_1 = v_on*r_off/(r_off-r_on);
     X.rprm[nr_v_on_1] = v_on_1;

     return;
   }
   v_on = X.rprm[nr_v_on];

   if (G.flags[G.i_dc] || G.flags[G.i_trns] || G.flags[G.i_startup]) {
     vp = X.val_nd[nnd_p];
     vn = X.val_nd[nnd_n];
     v0 = vp-vn;

     r_on    = X.rprm[nr_r_on  ];
     r_off   = X.rprm[nr_r_off ];
     v_on_1  = X.rprm[nr_v_on_1];

     if (v0 &gt;= v_on_1) {
       r = r_on;
     } else {
       r = r_off;
     }
     if (r &lt; 1.0e-9) {
       cout &lt;&lt; &quot;diode_r: r too small!&quot; &lt;&lt; endl;
       exit(1);
     }
     g = 1.0/r;
   }
   if (G.flags[G.i_dc] || G.flags[G.i_trns]) {
     if (G.flags[G.i_function]) {
       if (v0 &gt;= v_on_1) {
         X.f[nf_1] = g*(vp-vn)-g*v_on;
       } else {
         X.f[nf_1] = g*(vp-vn);
       }
       X.f[nf_2] = -X.f[nf_1];
     }
     if (G.flags[G.i_jacobian]) {
       J.dfdv[nf_1][nnd_p] =  g;
       J.dfdv[nf_1][nnd_n] = -g;
       J.dfdv[nf_2][nnd_p] = -g;
       J.dfdv[nf_2][nnd_n] =  g;
     }
     return;
   }
   if (G.flags[G.i_startup]) {
     if (G.flags[G.i_function]) {
       if (v0 &gt;= v_on_1) {
         X.h[nh_1] = g*(vp-vn)-g*v_on;
       } else {
         X.h[nh_1] = g*(vp-vn);
       }
       X.h[nh_2] = -X.h[nh_1];
     }
     if (G.flags[G.i_jacobian]) {
       J.dhdv[nh_1][nnd_p] =  g;
       J.dhdv[nh_1][nnd_n] = -g;
       J.dhdv[nh_2][nnd_p] = -g;
       J.dhdv[nh_2][nnd_n] =  g;
     }
     return;
   }
   if (G.flags[G.i_outvar]) {
     X.outprm[no_v] = X.val_nd[nnd_p]-X.val_nd[nnd_n];
     X.outprm[no_i] = X.cur_nd[nnd_p];
     return;
   }
   if (G.flags[G.i_init_guess]) {
      X.val_nd[nnd_n] = 0.0;
      X.val_nd[nnd_p] = 0.0;
      return;
   }
endC
endebe
</pre></div>
</td></tr></table></div>
<p>The <code class="docutils literal notranslate"><span class="pre">diode_r.ebe</span></code> template is similar to <code class="docutils literal notranslate"><span class="pre">r.ebe</span></code> in many respects.
The key differences are</p>
<ul class="simple">
<li><span class="math notranslate nohighlight">\(V_p\)</span> and <span class="math notranslate nohighlight">\(V_n\)</span> are used to figure out if the diode is
conducting or not. For the resistor, no such decision is required.</li>
<li>The fact that the Jacobian values depend on
<span class="math notranslate nohighlight">\(V_p\)</span> and
<span class="math notranslate nohighlight">\(V_n\)</span> is indicated by the statement,
<code class="docutils literal notranslate"><span class="pre">Jacobian:</span> <span class="pre">variable</span></code>.</li>
</ul>
</div>
<div class="section" id="c-ebe">
<span id="capacitor"></span><h3>c.ebe<a class="headerlink" href="#c-ebe" title="Permalink to this headline">¶</a></h3>
<p>This is the capacitor element with nodes <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">n</span></code>, and
capacitance <code class="docutils literal notranslate"><span class="pre">c</span></code>. The template is reproduced below.</p>
<div class="highlight-text notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80</pre></div></td><td class="code"><div class="highlight"><pre><span></span>ebe name=c
Jacobian: constant
nodes: p n
state_vars: qp qm
aux_vars:
aux_vars_startup: cur_p
x_vars:
iparms:
sparms:
rparms:
+  c=1.0
+  k_scale=1
stparms: v0=0
igparms:
outparms: i v
n_f=2
f_1: d_dt(qp)
f_2: d_dt(qm)
n_g=2
g_1: qp v(p) v(n)
g_2: qm v(p) v(n)
n_h=3
h_1: cur_p
h_2: cur_p
h_3: v(p) v(n)
C:
variables:
   double c1;
source:
   c = X.rprm[nr_c];
   k_scale = X.rprm[nr_k_scale];
   c1 = c*k_scale;

   if (G.flags[G.i_dc] || G.flags[G.i_trns]) {
      if (G.flags[G.i_function]) {
         X.f[nf_1] = 0.0;
         X.f[nf_2] = 0.0;

         X.g[ng_1] = c1*(X.val_nd[nnd_p]-X.val_nd[nnd_n]);
         X.g[ng_2] = -X.g[ng_1];
      }
      if (G.flags[G.i_jacobian]) {
         J.dgdv[ng_1][nnd_p] =  c1;
         J.dgdv[ng_1][nnd_n] = -c1;
         J.dgdv[ng_2][nnd_p] = -c1;
         J.dgdv[ng_2][nnd_n] =  c1;
      }
      X.val_stv[nstv_qp] = c1*(X.val_nd[nnd_p]-X.val_nd[nnd_n]);
      X.val_stv[nstv_qm] = -X.val_stv[nstv_qp];
   }
   if (G.flags[G.i_startup]) {
      v0 = X.stprm[nst_v0];
      cur_p = X.val_auxs[nas_cur_p];
      if (G.flags[G.i_function]) {
         X.h[nh_1] =  cur_p;
         X.h[nh_2] = -cur_p;
         X.h[nh_3] = X.val_nd[nnd_p]-X.val_nd[nnd_n]-v0;
      }
      if (G.flags[G.i_jacobian]) {
         J.dhdauxs[nh_1][nas_cur_p] =  1.0;
         J.dhdauxs[nh_2][nas_cur_p] = -1.0;
         J.dhdv   [nh_3][nnd_p    ] =  1.0;
         J.dhdv   [nh_3][nnd_n    ] = -1.0;
      }
      X.val_stv[nstv_qp] = c1*(X.val_nd[nnd_p]-X.val_nd[nnd_n]);
      X.val_stv[nstv_qm] = -X.val_stv[nstv_qp];
      return;
   }
   if (G.flags[G.i_outvar]) {
      X.outprm[no_v] = X.val_nd[nnd_p]-X.val_nd[nnd_n];
      X.outprm[no_i] = X.cur_nd[nnd_p];
      return;
   }
   if (G.flags[G.i_init_guess]) {
      X.val_nd[nnd_p] = 0.0;
      X.val_nd[nnd_n] = 0.0;
      return;
   }
endC
endebe
</pre></div>
</td></tr></table></div>
<p>The capacitor template has significant differences with respect to
the resistor template since the element equations for a capacitor
involve time derivatives. The following points may be noted.</p>
<ul class="simple">
<li>There are two state variables: <code class="docutils literal notranslate"><span class="pre">qp</span></code> and <code class="docutils literal notranslate"><span class="pre">qm</span></code>; they correspond
to the charges
<span class="math notranslate nohighlight">\(Q_p\)</span> and
<span class="math notranslate nohighlight">\(Q_m\)</span>, respectively (see the equations below).</li>
<li>There is a start-up auxiliary variable called <code class="docutils literal notranslate"><span class="pre">cur_p</span></code>.</li>
<li>In addition to the <code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">h</span></code> equations, the capacitor
templates also involves <code class="docutils literal notranslate"><span class="pre">g</span></code> functions.</li>
</ul>
<p>In order to understand the functioning of <code class="docutils literal notranslate"><span class="pre">c.ebe</span></code>, let us look at
the equations the capacitor must satisfy:</p>
<div class="math notranslate nohighlight" id="equation-eq-c-1">
<span class="eqno">(29)<a class="headerlink" href="#equation-eq-c-1" title="Permalink to this equation">¶</a></span>\[i_p = \displaystyle\frac{dQ_p}{dt},\]</div>
<div class="math notranslate nohighlight" id="equation-eq-c-2">
<span class="eqno">(30)<a class="headerlink" href="#equation-eq-c-2" title="Permalink to this equation">¶</a></span>\[i_n = \displaystyle\frac{dQ_m}{dt},\]</div>
<p>where</p>
<div class="math notranslate nohighlight" id="equation-eq-c-3">
<span class="eqno">(31)<a class="headerlink" href="#equation-eq-c-3" title="Permalink to this equation">¶</a></span>\[Q_p = C\times (v_p-v_n),\]</div>
<div class="math notranslate nohighlight" id="equation-eq-c-4">
<span class="eqno">(32)<a class="headerlink" href="#equation-eq-c-4" title="Permalink to this equation">¶</a></span>\[Q_m = -C\times (v_p-v_n),\]</div>
<p>Eqs. <a class="reference internal" href="#equation-eq-c-3">(31)</a> and <a class="reference internal" href="#equation-eq-c-4">(32)</a> are implemented using the
<code class="docutils literal notranslate"><span class="pre">g</span></code> functions in the transient simulation section of the
template. The <code class="docutils literal notranslate"><span class="pre">f</span></code> functions, which are supposed to specify
<span class="math notranslate nohighlight">\(i_p\)</span> and <span class="math notranslate nohighlight">\(i_n\)</span>, are 0 in this case because the
dependence of these currents on the derivatives
<span class="math notranslate nohighlight">\(\displaystyle\frac{dQ_p}{dt}\)</span> and
<span class="math notranslate nohighlight">\(\displaystyle\frac{dQ_m}{dt}\)</span> is already conveyed to
the simulator in the <code class="docutils literal notranslate"><span class="pre">f_1:</span></code> and <code class="docutils literal notranslate"><span class="pre">f_2:</span></code> statements.</p>
<p><strong>Start-up simulation:</strong> In this situation, the state variables
are held constant at their specified values, and the circuit
equations are solved with those constraints.
In start-up simulation, the capacitor behaves like a dc voltage
source, satisfying the equations,</p>
<div class="math notranslate nohighlight" id="equation-eq-c-5">
<span class="eqno">(33)<a class="headerlink" href="#equation-eq-c-5" title="Permalink to this equation">¶</a></span>\[i_p = i_1,\]</div>
<div class="math notranslate nohighlight" id="equation-eq-c-6">
<span class="eqno">(34)<a class="headerlink" href="#equation-eq-c-6" title="Permalink to this equation">¶</a></span>\[i_n = -i_1,\]</div>
<div class="math notranslate nohighlight" id="equation-eq-c-7">
<span class="eqno">(35)<a class="headerlink" href="#equation-eq-c-7" title="Permalink to this equation">¶</a></span>\[v_p-v_n = V_0,\]</div>
<p>where <span class="math notranslate nohighlight">\(V_0\)</span> is specified by the start-up parameter
<code class="docutils literal notranslate"><span class="pre">v0</span></code> in the template. The current <span class="math notranslate nohighlight">\(i_1\)</span> is an
auxiliary variable here and corresponds to <code class="docutils literal notranslate"><span class="pre">cur_p</span></code> in
the template. Implementation of these equations can be seen
in the start-up part in the <code class="docutils literal notranslate"><span class="pre">C</span></code> part of the template.</p>
</div>
<div class="section" id="l-ebe">
<span id="inductor"></span><h3>l.ebe<a class="headerlink" href="#l-ebe" title="Permalink to this headline">¶</a></h3>
<p>This is the inductor element with nodes <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">n</span></code>, and
inductance <code class="docutils literal notranslate"><span class="pre">l</span></code>. The template is reproduced below.</p>
<div class="highlight-text notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66</pre></div></td><td class="code"><div class="highlight"><pre><span></span>ebe name=l
Jacobian: constant
nodes: p n
state_vars:
aux_vars: cur_p
aux_vars_startup:
x_vars:
iparms:
sparms:
rparms:
+  l=1.0
+  k_scale=1
stparms: i0=0
igparms:
outparms: i v
n_f=3
f_1: cur_p
f_2: cur_p
f_3: d_dt(cur_p) v(p) v(n)
n_g=0
n_h=2
h_1:
h_2:
C:
variables:
   double l1;
source:
   if (G.flags[G.i_dc] || G.flags[G.i_trns]) {
     l = X.rprm[nr_l];
     k_scale = X.rprm[nr_k_scale];
     l1 = l*k_scale;

     cur_p = X.val_aux[na_cur_p];
     if (G.flags[G.i_function]) {
       X.f[nf_1] =  cur_p;
       X.f[nf_2] = -cur_p;
       X.f[nf_3] = (X.val_nd[nnd_p]-X.val_nd[nnd_n])/l1;
     }
     if (G.flags[G.i_jacobian]) {
       J.dfdaux[nf_1][na_cur_p] =  1.0;
       J.dfdaux[nf_2][na_cur_p] = -1.0;
       J.dfdv  [nf_3][nnd_p   ] =  1.0/l1;
       J.dfdv  [nf_3][nnd_n   ] = -1.0/l1;
     }
   }
   if (G.flags[G.i_startup]) {
      i0 = X.stprm[nst_i0];
      if (G.flags[G.i_function]) {
         X.h[nh_1] =  i0;
         X.h[nh_2] = -i0;
      }
      X.val_aux[na_cur_p] = i0;
      return;
   }
   if (G.flags[G.i_outvar]) {
      X.outprm[no_v] = X.val_nd[nnd_p]-X.val_nd[nnd_n];
      X.outprm[no_i] = X.cur_nd[nnd_p];
      return;
   }
   if (G.flags[G.i_init_guess]) {
      X.val_nd[nnd_p] = 0.0;
      X.val_nd[nnd_n] = 0.0;
      return;
   }
endC
endebe
</pre></div>
</td></tr></table></div>
<p>There is a significant difference between <code class="docutils literal notranslate"><span class="pre">c.ebe</span></code> and <code class="docutils literal notranslate"><span class="pre">l.ebe</span></code>
although both of these involve a time derivative. The difference
arises because the capacitor involves a voltage derivative whereas
the inductor involves a current derivative. In transient simulation,
the inductor equations are</p>
<div class="math notranslate nohighlight" id="equation-neq-inductor-trns">
<span class="eqno">(36)<a class="headerlink" href="#equation-neq-inductor-trns" title="Permalink to this equation">¶</a></span>\[\begin{split}\begin{align}
i_p &amp;= i_1\,,\\
i_n &amp;= -i_1\,,\\
\displaystyle\frac{di_1}{dt} &amp;= \displaystyle\frac{1}{L}\,\left(V_p-V_n\right)\,.
\end{align}\end{split}\]</div>
<p>These equations have been implemented in <code class="docutils literal notranslate"><span class="pre">l.ebe</span></code> using an <strong>auxiliary variable</strong>
<code class="docutils literal notranslate"><span class="pre">cur_p</span></code> which corresponds to <span class="math notranslate nohighlight">\(i_1\)</span> in the above equations. Although the
inductor current is a “state variable” (in the sense that the element behaviour
depends on <span class="math notranslate nohighlight">\(\displaystyle\frac{di_L}{dt}\)</span>), it is not declared in the
<code class="docutils literal notranslate"><span class="pre">state_vars</span></code> field of the template because of the way we have implemented the
inductor equations.</p>
<p>In start-up simulation, the indcutor equations are simply,</p>
<div class="math notranslate nohighlight" id="equation-neq-inductor-startup">
<span class="eqno">(37)<a class="headerlink" href="#equation-neq-inductor-startup" title="Permalink to this equation">¶</a></span>\[\begin{split}\begin{align}
i_p &amp;= i_0\,,\\
i_n &amp;= -i_0\,,
\end{align}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(i_0\)</span> corresponds to <code class="docutils literal notranslate"><span class="pre">i0</span></code> in the <code class="docutils literal notranslate"><span class="pre">stparms</span></code> field.</p>
</div>
</div>
<div class="section" id="ebe-f-g-h-functions">
<span id="ebe-fgh"></span><h2>ebe: f, g, h functions<a class="headerlink" href="#ebe-f-g-h-functions" title="Permalink to this headline">¶</a></h2>
<p>Consider an electrical element
with <span class="math notranslate nohighlight">\(N\)</span> nodes, as shown below.</p>
<a class="reference internal image-reference" href="_images/ebe_general.png"><img alt="general ebe" src="_images/ebe_general.png" style="width: 200px;" /></a>
<p><strong>Transient simulation:</strong>
In GSEIM, electrical elements are treated using
<a class="reference internal" href="mna.html#mna"><span class="std std-ref">modified nodal analysis</span></a> for writing
circuit equations and
<a class="reference internal" href="numerical.html#implicit"><span class="std std-ref">implicit methods</span></a> for solving ODEs,
leading to <a class="reference internal" href="numerical.html#sec-mna-trns"><span class="std std-ref">systematic assembly</span></a>
of circuit equations. If the resulting set of equations
is nonlinear, the <a class="reference internal" href="nr.html#nr"><span class="std std-ref">Newton-Raphson</span></a> iterative
method is used to obtain the solution (at each time point).
An ebe template must provide currents
<span class="math notranslate nohighlight">\(i_1\)</span>,
<span class="math notranslate nohighlight">\(i_2\)</span>,
<span class="math notranslate nohighlight">\(\cdots\)</span>,
<span class="math notranslate nohighlight">\(i_N\)</span>, and their derivatives,
given the node voltages,
<span class="math notranslate nohighlight">\(V_1\)</span>,
<span class="math notranslate nohighlight">\(V_2\)</span>,
<span class="math notranslate nohighlight">\(\cdots\)</span>,
<span class="math notranslate nohighlight">\(V_N\)</span>.
For some ebe’s, additional equations are required, and functions
related to those must also be computed by the ebe template
(e.g., see the inductor template, <code class="docutils literal notranslate"><span class="pre">l.ebe</span></code>).
The functions corresponding to the node currents as well
as additional equations (if any) are passed
by the template to the main program through vector <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p>
<p>When there are <code class="docutils literal notranslate"><span class="pre">state_vars</span></code> involved in the ebe equations,
the template needs to compute the associated functions and pass
them to the main programs through vector <code class="docutils literal notranslate"><span class="pre">g</span></code> (e.g., see the
computation of <code class="docutils literal notranslate"><span class="pre">qp</span></code> and <code class="docutils literal notranslate"><span class="pre">qm</span></code> in the capacitor template,
<code class="docutils literal notranslate"><span class="pre">c.ebe</span></code>).</p>
<p><strong>Start-up simulation:</strong>
For elements such as <code class="docutils literal notranslate"><span class="pre">r.ebe</span></code>, equations used for
<a class="reference internal" href="startup.html#startup"><span class="std std-ref">start-up simulation</span></a> are the same as those used
in transient simulation. For other elements, such as <code class="docutils literal notranslate"><span class="pre">c.ebe</span></code>, they
are different in transient and start-up simulation. In either
case, GSEIM expects the corresponding function
values to be supplied by the ebe template through vector <code class="docutils literal notranslate"><span class="pre">h</span></code>.</p>
<p>In both transient and start-up simulation, GSEIM uses the
Newton-Raphson method, and the relevant derivatives (Jacobian
values) also need to be computed by the ebe template.</p>
<p>The following figure summarises our discussion with respect to
ebe templates.</p>
<a class="reference internal image-reference" href="_images/ebe_trns.png"><img alt="ebe functions" src="_images/ebe_trns.png" style="width: 400px;" /></a>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">GSEIM</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="elements.html">Blocks and ports</a></li>
<li class="toctree-l1"><a class="reference internal" href="new_project.html">Creating a new project</a></li>
<li class="toctree-l1"><a class="reference internal" href="organisation.html">GSEIM Organisation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Element templates</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#xbe-templates">xbe templates</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#sum-2-xbe">sum_2.xbe</a></li>
<li class="toctree-l3"><a class="reference internal" href="#integrator-xbe">integrator.xbe</a></li>
<li class="toctree-l3"><a class="reference internal" href="#indmc1-xbe">indmc1.xbe</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#xbe-f-g-h-functions">xbe: f, g, h functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ebe-templates">ebe templates</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#r-ebe">r.ebe</a></li>
<li class="toctree-l3"><a class="reference internal" href="#diode-r-ebe">diode_r.ebe</a></li>
<li class="toctree-l3"><a class="reference internal" href="#c-ebe">c.ebe</a></li>
<li class="toctree-l3"><a class="reference internal" href="#l-ebe">l.ebe</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#ebe-f-g-h-functions">ebe: f, g, h functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="solve.html">Solve Blocks</a></li>
<li class="toctree-l1"><a class="reference internal" href="subckt.html">Subcircuits</a></li>
<li class="toctree-l1"><a class="reference internal" href="bedocs.html">Block Documents</a></li>
<li class="toctree-l1"><a class="reference internal" href="subckt_docs.html">Sub-circuit Documents</a></li>
<li class="toctree-l1"><a class="reference internal" href="proj_list.html">GSEIM projects</a></li>
<li class="toctree-l1"><a class="reference internal" href="mna.html">Modified nodal analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="nr.html">Newton-Raphson method</a></li>
<li class="toctree-l1"><a class="reference internal" href="numerical.html">Numerical methods for ODEs</a></li>
<li class="toctree-l1"><a class="reference internal" href="ssw.html">SSW computation</a></li>
<li class="toctree-l1"><a class="reference internal" href="startup.html">Start-up simulation</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="organisation.html" title="previous chapter">GSEIM Organisation</a></li>
      <li>Next: <a href="solve.html" title="next chapter">Solve Blocks</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, Mahesh Patil.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.8</a>
      
      |
      <a href="_sources/templates.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Element templates (xbe) &#8212; GSEIM 0.0.1 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="f, g, h functions" href="functions.html" />
    <link rel="prev" title="GSEIM Organisation" href="organisation.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="element-templates-xbe">
<span id="xbe"></span><h1>Element templates (<code class="docutils literal notranslate"><span class="pre">xbe</span></code>)<a class="headerlink" href="#element-templates-xbe" title="Permalink to this headline">¶</a></h1>
<p>A very important feature of GSEIM is that it allows the user to
add new functionality in the form of library elements, by
writing suitable <strong>templates</strong>.
In this section, we look at the syntax of element templates
with the help of some examples. We start with a few remarks.</p>
<ul class="simple">
<li>Element templates are files with extension <code class="docutils literal notranslate"><span class="pre">.xbe</span></code>
(<em>explicit basic element</em>) in <code class="docutils literal notranslate"><span class="pre">~/gseim_gui/gseim/xbe/</span></code>.</li>
<li>An element template has three types of variables in general:
input, output, and auxiliary. Only the input and output variables
are made available in the schematic capture GUI for connection to
other elements.</li>
<li>Two types of elements are allowed:<ul>
<li><code class="docutils literal notranslate"><span class="pre">evaluate</span></code> type in which the element equations are of the form
<span class="math notranslate nohighlight">\(y = f(x_1,x_2,..)\)</span>
where <span class="math notranslate nohighlight">\(y\)</span> is an output and
<span class="math notranslate nohighlight">\(x_1\)</span>,
<span class="math notranslate nohighlight">\(x_2\)</span>, etc.
are inputs. These elements do not involve time derivatives.</li>
<li><code class="docutils literal notranslate"><span class="pre">integrate</span></code> type with equations of the form
<span class="math notranslate nohighlight">\(\displaystyle\frac{dy}{dt} = f(x_1,x_2,..)\)</span> where
<span class="math notranslate nohighlight">\(y\)</span> is an
output or auxiliary variable, and
<span class="math notranslate nohighlight">\(x_1\)</span>,
<span class="math notranslate nohighlight">\(x_2\)</span>, etc.
can be input, output, or auxiliary variables.</li>
</ul>
</li>
</ul>
<div class="section" id="xbe-template-examples">
<h2><code class="docutils literal notranslate"><span class="pre">xbe</span></code> template examples<a class="headerlink" href="#xbe-template-examples" title="Permalink to this headline">¶</a></h2>
<p>In the following, we look at a few representative examples
to explain the functioning of the <code class="docutils literal notranslate"><span class="pre">xbe</span></code> templates. The
templates described here can be found in
<code class="docutils literal notranslate"><span class="pre">~/gseim_gui/gseim/xbe</span></code>.</p>
<div class="section" id="sum-2-xbe">
<span id="sum-2"></span><h3><code class="docutils literal notranslate"><span class="pre">sum_2.xbe</span></code><a class="headerlink" href="#sum-2-xbe" title="Permalink to this headline">¶</a></h3>
<p>This element is used to obtain</p>
<div class="math notranslate nohighlight">
\[y = k_1x_1 + k_2x_2,\]</div>
<p>where
<span class="math notranslate nohighlight">\(x_1\)</span>,
<span class="math notranslate nohighlight">\(x_2\)</span> are input variables,
<span class="math notranslate nohighlight">\(y\)</span> is the output variable, and
<span class="math notranslate nohighlight">\(k_1\)</span>,
<span class="math notranslate nohighlight">\(k_2\)</span> are real parameters.
This is an <code class="docutils literal notranslate"><span class="pre">evaluate</span></code> type element, i.e., its output can be written
as a function of its inputs, and it does not involve time derivatives.
The overall structure of <code class="docutils literal notranslate"><span class="pre">sum_2.xbe</span></code> is given below.</p>
<div class="highlight-text notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46</pre></div></td><td class="code"><div class="highlight"><pre><span></span>xbe name=sum_2 evaluate=yes
# y = k1*x1 + k2*x2
Jacobian: constant
input_vars: x1 x2
output_vars: y
aux_vars:
iparms:
sparms:
rparms: k1=1 k2=1
stparms:
igparms:
outparms: x1 x2 y
n_f= 0
n_g= 1
g_1: x1 x2 y
C:
   k1 = X.rprm[nr_k1];
   k2 = X.rprm[nr_k2];
   if (G.flags[G.i_init_guess]) {
     X.val_vr[nvr_y] = k1*X.val_vr[nvr_x1] + k2*X.val_vr[nvr_x2];
     return;
   }
   if (G.flags[G.i_trns] || G.flags[G.i_startup]) {
     if (G.flags[G.i_explicit]) {
       X.val_vr[nvr_y] = k1*X.val_vr[nvr_x1] + k2*X.val_vr[nvr_x2];
     } else if (G.flags[G.i_implicit]) {
       if (G.flags[G.i_function]) {
         X.g[ng_1] = X.val_vr[nvr_y]
           - k1*X.val_vr[nvr_x1] - k2*X.val_vr[nvr_x2];
       }
       if (G.flags[G.i_jacobian]) {
         J.dgdvr[ng_1][nvr_y ] =  1.0;
         J.dgdvr[ng_1][nvr_x1] = -k1;
         J.dgdvr[ng_1][nvr_x2] = -k2;
       }
     }
     return;
   }
   if (G.flags[G.i_outvar]) {
     X.outprm[no_x1] = X.val_vr[nvr_x1];
     X.outprm[no_x2] = X.val_vr[nvr_x2];
     X.outprm[no_y ] = X.val_vr[nvr_y ];
     return;
   }
endC
endxbe
</pre></div>
</td></tr></table></div>
<p>Note the following features in the template:</p>
<ul class="simple">
<li>The element name is specified by the keyword <code class="docutils literal notranslate"><span class="pre">name</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">evaluate=yes</span></code> specifies the element type.</li>
<li>A line starting with <code class="docutils literal notranslate"><span class="pre">#</span></code> is a comment.</li>
<li><code class="docutils literal notranslate"><span class="pre">Jacobian:</span> <span class="pre">constant</span></code> indicates that,
when the element equation
<span class="math notranslate nohighlight">\(y - k_1x_1 - k_2x_2 = 0\)</span>
is differentiated with respect to the variables involved
in the equation, we get constants.</li>
<li>The lines <code class="docutils literal notranslate"><span class="pre">input_vars</span></code> and <code class="docutils literal notranslate"><span class="pre">output_vars</span></code> specify
the input and output variables of the element, respectively.</li>
<li>The names and default values of the real parameters are given
by the <code class="docutils literal notranslate"><span class="pre">rparms</span></code> statement. (GSEIM also allows integer and
string parameters; they are not used in <code class="docutils literal notranslate"><span class="pre">sum_2</span></code>).</li>
<li>The <code class="docutils literal notranslate"><span class="pre">outparms</span></code> statement specifies the names of output
parameters which will be made available by this template
during simulation (if requested by the user).</li>
<li>The <code class="docutils literal notranslate"><span class="pre">n_f</span></code> and <code class="docutils literal notranslate"><span class="pre">n_g</span></code> statements specify the number
of <code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span></code> functions for this element. (This aspect will be
described in the <a class="reference internal" href="functions.html#functions"><span class="std std-ref">Functions</span></a> section.)</li>
<li>The <code class="docutils literal notranslate"><span class="pre">g_1</span></code> statement indicates the variables involved in
the function
<span class="math notranslate nohighlight">\(g_1\)</span>.</li>
<li>The C++ section of the template appears
between the <code class="docutils literal notranslate"><span class="pre">C</span></code> and <code class="docutils literal notranslate"><span class="pre">endC</span></code> statements.</li>
</ul>
<p>The behaviour of this element is coded in the C++
section of the template.  In order to understand this section, we need to
see where it fits in the overall scheme, as explained in the following.</p>
<p>There is a GSEIM library preprocessor which picks up the C++ section
of each <code class="docutils literal notranslate"><span class="pre">xbe</span></code> template (as also the other details such as input
and output variables, real parameters, etc.) and uses it to prepare
a C++ routine for that specific <code class="docutils literal notranslate"><span class="pre">xbe</span></code>. All of these <code class="docutils literal notranslate"><span class="pre">xbe</span></code>
routines are then compiled together with the solver code of GSEIM
to prepare the executable file for the solver.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">sum_2</span></code> routine (function) receives objects <code class="docutils literal notranslate"><span class="pre">G</span></code>
and <code class="docutils literal notranslate"><span class="pre">X</span></code> from the GSEIM main program and is expected to compute
various quantities such function values, output parameters, etc.
Objects <code class="docutils literal notranslate"><span class="pre">G</span></code> and <code class="docutils literal notranslate"><span class="pre">X</span></code> may be described as follows.</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">G</span></code> is a global object and is used to pass information
about the current time point, type of method being used (implicit or
explicit), etc. It also conveys to the element routine, through the
<code class="docutils literal notranslate"><span class="pre">flags</span></code> array, what computation the main program is expecting
from the element routine in the present call.</li>
<li><code class="docutils literal notranslate"><span class="pre">X</span></code> is specific to the element being treated, and it contains
variables and parameter values related to that element.</li>
</ul>
<p>With this background, let us now look at the C++ routine
prepared by the library preprocessor for <code class="docutils literal notranslate"><span class="pre">sum_2.xbe</span></code>:</p>
<div class="highlight-text notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43</pre></div></td><td class="code"><div class="highlight"><pre><span></span>void x_sum_2(Global &amp;G,XbeUsr &amp;X,XbeJac &amp;J) {
   double x1,x2;
   double y;
   double k1,k2;
   const int nvr_x1 = 0;
   const int nvr_x2 = 1;
   const int nvr_y = 2;
   const int nr_k1 = 0;
   const int nr_k2 = 1;
   const int no_x1 = 0;
   const int no_x2 = 1;
   const int no_y = 2;
   const int ng_1 = 0;
   k1 = X.rprm[nr_k1];
   k2 = X.rprm[nr_k2];
   if (G.flags[G.i_init_guess]) {
     X.val_vr[nvr_y] = k1*X.val_vr[nvr_x1] + k2*X.val_vr[nvr_x2];
     return;
   }
   if (G.flags[G.i_trns] || G.flags[G.i_startup]) {
     if (G.flags[G.i_explicit]) {
       X.val_vr[nvr_y] = k1*X.val_vr[nvr_x1] + k2*X.val_vr[nvr_x2];
     } else if (G.flags[G.i_implicit]) {
       if (G.flags[G.i_function]) {
         X.g[ng_1] = X.val_vr[nvr_y]
           - k1*X.val_vr[nvr_x1] - k2*X.val_vr[nvr_x2];
       }
       if (G.flags[G.i_jacobian]) {
         J.dgdvr[ng_1][nvr_y ] =  1.0;
         J.dgdvr[ng_1][nvr_x1] = -k1;
         J.dgdvr[ng_1][nvr_x2] = -k2;
       }
     }
     return;
   }
   if (G.flags[G.i_outvar]) {
     X.outprm[no_x1] = X.val_vr[nvr_x1];
     X.outprm[no_x2] = X.val_vr[nvr_x2];
     X.outprm[no_y ] = X.val_vr[nvr_y ];
     return;
   }
   return;
}
</pre></div>
</td></tr></table></div>
<p>Note that the library preprocessor has simply inserted
the C++ section of <code class="docutils literal notranslate"><span class="pre">sum_2.xbe</span></code> into this routine
without any changes. In addition, it has added the following.</p>
<ul class="simple">
<li>declaration for <code class="docutils literal notranslate"><span class="pre">x1</span></code>, <code class="docutils literal notranslate"><span class="pre">x2</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, <code class="docutils literal notranslate"><span class="pre">k1</span></code>, <code class="docutils literal notranslate"><span class="pre">k2</span></code>: This allows
the user to use these variables without having to declare them
manually.</li>
<li>assignment of integers <code class="docutils literal notranslate"><span class="pre">nvr_x1</span></code>, <code class="docutils literal notranslate"><span class="pre">nvr_x2</span></code>, <code class="docutils literal notranslate"><span class="pre">nvr_y</span></code>, <code class="docutils literal notranslate"><span class="pre">nr_k1</span></code>,
<code class="docutils literal notranslate"><span class="pre">nr_k2</span></code> <code class="docutils literal notranslate"><span class="pre">no_x1</span></code>, <code class="docutils literal notranslate"><span class="pre">no_x2</span></code>, <code class="docutils literal notranslate"><span class="pre">no_y</span></code>, <code class="docutils literal notranslate"><span class="pre">ng_1</span></code>: These constants
are convenient in accessing the attributes of the <code class="docutils literal notranslate"><span class="pre">xbe</span></code>. For
example, <code class="docutils literal notranslate"><span class="pre">X.val_vr[nvr_x1]</span></code> gives the current value of <code class="docutils literal notranslate"><span class="pre">x1</span></code> for
this element.</li>
</ul>
<p>It is now easy to see the following points about <code class="docutils literal notranslate"><span class="pre">sum_2.xbe</span></code>:</p>
<ul>
<li><p class="first">If an explicit method is being used, the template
evaluates <code class="docutils literal notranslate"><span class="pre">y</span></code> in terms of <code class="docutils literal notranslate"><span class="pre">x1</span></code> and <code class="docutils literal notranslate"><span class="pre">x2</span></code>.</p>
</li>
<li><p class="first">If an implicit method is being used, the template supplies
information about the equation it satisfies, viz.,</p>
<div class="math notranslate nohighlight">
\[g_1 \equiv y - (k_1x_1 + k_2x_2) = 0.\]</div>
<p>If the main program is requesting the function value,
<span class="math notranslate nohighlight">\(g_1(x_1,x_2,y)\)</span> is
evaluated; if it is requesting the derivatives, then
<span class="math notranslate nohighlight">\(\displaystyle\frac{\partial g_1}{\partial x_1}\)</span>,
<span class="math notranslate nohighlight">\(\displaystyle\frac{\partial g_1}{\partial x_2}\)</span>,
<span class="math notranslate nohighlight">\(\displaystyle\frac{\partial g_1}{\partial y}\)</span>
are evaluated.</p>
</li>
<li><p class="first">If the program is requesting assignment of output parameters, the
parameters listed in the <code class="docutils literal notranslate"><span class="pre">outparms</span></code> statement of <code class="docutils literal notranslate"><span class="pre">sum_2.xbe</span></code>
are assigned.</p>
</li>
</ul>
</div>
<div class="section" id="integrator-xbe">
<h3><code class="docutils literal notranslate"><span class="pre">integrator.xbe</span></code><a class="headerlink" href="#integrator-xbe" title="Permalink to this headline">¶</a></h3>
<p>Next, we consider an element of type <code class="docutils literal notranslate"><span class="pre">integrate</span></code>, viz., the
integrator, which satisfies</p>
<div class="math notranslate nohighlight" id="equation-eq-integrator">
<span class="eqno">(1)<a class="headerlink" href="#equation-eq-integrator" title="Permalink to this equation">¶</a></span>\[y = k\,\int x\,dt,\]</div>
<p>where <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> are the input and
output variables, respectively, and <code class="docutils literal notranslate"><span class="pre">k</span></code> is a real parameter.
Since GSEIM expects the equations to be written
in the general form</p>
<div class="math notranslate nohighlight">
\[\displaystyle\frac{dy}{dt} = f(x_1,x_2,..),\]</div>
<p>we rewrite Eq. <a class="reference internal" href="#equation-eq-integrator">(1)</a> as</p>
<div class="math notranslate nohighlight">
\[\displaystyle\frac{dy}{dt} = \,k\,x.\]</div>
<p>For <code class="docutils literal notranslate"><span class="pre">integrate</span></code> type elements, we also need to specify
the initial or <em>start-up</em> value of the state variable(s).
For the integrator, we will denote that by <span class="math notranslate nohighlight">\(y_0\)</span>.</p>
<p>The integrator template is shown below.</p>
<div class="highlight-text notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63</pre></div></td><td class="code"><div class="highlight"><pre><span></span>xbe name=integrator integrate=yes
# y = k int (x dt)
Jacobian: constant
input_vars: x
output_vars: y
aux_vars:
iparms:
sparms:
rparms: k=1
stparms: y_st=0
igparms: y_ig=0
outparms: x y
n_f= 1
f_1: d_dt(y)
n_g= 1
g_1: x
C:
prototypes:
variables:
source:
   if (G.flags[G.i_one_time_parms]) {
     return;
   }
   if (G.flags[G.i_init_guess]) {
     X.val_vr [nvr_y] = X.igprm[nig_y_ig];
     return;
   }
   if (G.flags[G.i_startup]) {
     if (G.flags[G.i_explicit]) {
       X.val_vr[nvr_y] = X.stprm[nst_y_st];
     } else if (G.flags[G.i_implicit]) {
       X.h[nf_1] = X.val_vr[nvr_y] - X.stprm[nst_y_st];
     }
     return;
   }
   if (G.flags[G.i_outvar]) {
     X.outprm[no_x] = X.val_vr[nvr_x];
     X.outprm[no_y] = X.val_vr[nvr_y];
     return;
   }
   if (G.flags[G.i_trns]) {
     if (G.flags[G.i_explicit]) {
       if (G.flags[G.i_alg_loop]) {
         X.h[nf_1] = X.val_vr[nvr_y] - X.val_vr_u[nvr_y];
       } else {
         k = X.rprm[nr_k];
         x = X.val_vr[nvr_x];
         X.f[nf_1] = k*x;
       }
     } else if (G.flags[G.i_implicit]) {
       k = X.rprm[nr_k];
       x = X.val_vr[nvr_x];
       if (G.flags[G.i_function]) {
         X.g[ng_1] = k*x;
       }
       if (G.flags[G.i_jacobian]) {
         J.dgdvr[ng_1][nvr_x] = k;
       }
     }
     return;
   }
endC
endxbe
</pre></div>
</td></tr></table></div>
<p>The structure of <code class="docutils literal notranslate"><span class="pre">integrator.xbe</span></code> is similar to that of
<a class="reference internal" href="#sum-2"><span class="std std-ref">sum_2.xbe</span></a>; here, we will only point out the
new features.</p>
<p>The start-up parameter <code class="docutils literal notranslate"><span class="pre">y_st</span></code> corresponds to <span class="math notranslate nohighlight">\(y_0\)</span>
mentioned above. The fact that time derivative of <code class="docutils literal notranslate"><span class="pre">y</span></code> is
involved in the element equation is indicated by the
<code class="docutils literal notranslate"><span class="pre">f_1</span></code> statement.</p>
<p>In the C++ part of the template,
we have different sections for start-up and transient simulation.
In the start-up section, the equation <span class="math notranslate nohighlight">\(y = y_0\)</span> is handled.
In the transient section, if the method is explicit, only the
function <span class="math notranslate nohighlight">\(f_1 = k\,x\)</span> is evaluated; if it is implicit,
the function <span class="math notranslate nohighlight">\(g_1 = k\,x\)</span> as well as its derivative
<span class="math notranslate nohighlight">\(\displaystyle\frac{\partial g_1}{\partial x}\)</span> are computed.</p>
</div>
<div class="section" id="indmc1-xbe">
<h3><code class="docutils literal notranslate"><span class="pre">indmc1.xbe</span></code><a class="headerlink" href="#indmc1-xbe" title="Permalink to this headline">¶</a></h3>
<p>We now look at a more complex element of type <code class="docutils literal notranslate"><span class="pre">integrate</span></code>,
viz., <code class="docutils literal notranslate"><span class="pre">indmc1.xbe</span></code>, which implements the induction machine model
given by,</p>
<div class="math notranslate nohighlight" id="equation-eq-indmc-1">
<span class="eqno">(2)<a class="headerlink" href="#equation-eq-indmc-1" title="Permalink to this equation">¶</a></span>\[\displaystyle\frac{d{\psi}_{ds}}{dt} = v_{ds}-r_si_{ds},\]</div>
<div class="math notranslate nohighlight" id="equation-eq-indmc-2">
<span class="eqno">(3)<a class="headerlink" href="#equation-eq-indmc-2" title="Permalink to this equation">¶</a></span>\[\displaystyle\frac{d{\psi}_{qs}}{dt} = v_{qs}-r_si_{qs},\]</div>
<div class="math notranslate nohighlight" id="equation-eq-indmc-3">
<span class="eqno">(4)<a class="headerlink" href="#equation-eq-indmc-3" title="Permalink to this equation">¶</a></span>\[\displaystyle\frac{d{\psi}_{dr}}{dt} = -\,\frac{P}{2}\,\omega_ {rm}\psi _{qr}-r_ri_{dr},\]</div>
<div class="math notranslate nohighlight" id="equation-eq-indmc-4">
<span class="eqno">(5)<a class="headerlink" href="#equation-eq-indmc-4" title="Permalink to this equation">¶</a></span>\[\displaystyle\frac{d{\psi}_{qr}}{dt} =  \frac{P}{2}\,\omega_ {rm}\psi _{dr}-r_ri_{qr},\]</div>
<div class="math notranslate nohighlight" id="equation-eq-indmc-5">
<span class="eqno">(6)<a class="headerlink" href="#equation-eq-indmc-5" title="Permalink to this equation">¶</a></span>\[\displaystyle\frac{d{\omega}_{rm}}{dt} = \frac{1}{J}\,(T_{em}-T_L),\]</div>
<p>where</p>
<div class="math notranslate nohighlight" id="equation-eq-indmc1-1">
<span class="eqno">(7)<a class="headerlink" href="#equation-eq-indmc1-1" title="Permalink to this equation">¶</a></span>\[i_{ds} = \frac{L_r}{L_m L_e}\,\psi _{ds} - \frac{1}{L_e}\,\psi _{dr},\]</div>
<div class="math notranslate nohighlight" id="equation-eq-indmc1-2">
<span class="eqno">(8)<a class="headerlink" href="#equation-eq-indmc1-2" title="Permalink to this equation">¶</a></span>\[i_{qs} = \frac{L_r}{L_m L_e}\,\psi _{qs} - \frac{1}{L_e}\,\psi _{qr},\]</div>
<div class="math notranslate nohighlight" id="equation-eq-indmc1-3">
<span class="eqno">(9)<a class="headerlink" href="#equation-eq-indmc1-3" title="Permalink to this equation">¶</a></span>\[i_{dr} = \frac{1}{L_m}\,\psi _{ds} - \left(\frac{L_{ls}}{L_m}+1\right)~i _{ds},\]</div>
<div class="math notranslate nohighlight" id="equation-eq-indmc1-4">
<span class="eqno">(10)<a class="headerlink" href="#equation-eq-indmc1-4" title="Permalink to this equation">¶</a></span>\[i_{qr} = \frac{1}{L_m}\,\psi _{qs} - \left(\frac{L_{ls}}{L_m}+1\right)~i _{qs},\]</div>
<div class="math notranslate nohighlight" id="equation-eq-indmc1-5">
<span class="eqno">(11)<a class="headerlink" href="#equation-eq-indmc1-5" title="Permalink to this equation">¶</a></span>\[T_{em} = \frac{3}{4}\, P L_m\,(i_{qs}i_{dr} - i_{ds}i_{qr}),\]</div>
<p>with</p>
<div class="math notranslate nohighlight" id="equation-eq-indmc2-1">
<span class="eqno">(12)<a class="headerlink" href="#equation-eq-indmc2-1" title="Permalink to this equation">¶</a></span>\[L_e = \displaystyle\frac{L_sL_r}{L_m}-L_m`,\]</div>
<div class="math notranslate nohighlight" id="equation-eq-indmc2-2">
<span class="eqno">(13)<a class="headerlink" href="#equation-eq-indmc2-2" title="Permalink to this equation">¶</a></span>\[L_s = L_{ls}+L_m`,\]</div>
<div class="math notranslate nohighlight" id="equation-eq-indmc2-3">
<span class="eqno">(14)<a class="headerlink" href="#equation-eq-indmc2-3" title="Permalink to this equation">¶</a></span>\[L_r = L_{lr}+L_m`.\]</div>
<p>Since the <code class="docutils literal notranslate"><span class="pre">indmc.xbe</span></code> template is rather long, we will split
it into several pieces for the purpose of discussion. The complete
template can be found in <code class="docutils literal notranslate"><span class="pre">~/gseim_gui/gseim/xbe/</span></code>.</p>
<p>Here is the overall template, without the C++ part:</p>
<div class="highlight-text notranslate" id="indmc1"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57</pre></div></td><td class="code"><div class="highlight"><pre><span></span>xbe name=indmc1 integrate=yes
# induction motor model
Jacobian: variable
input_vars: vqs vds tl
output_vars: wrm
aux_vars:
+  psids psidr psiqs psiqr
iparms:
+  poles=4
sparms:
rparms:
+  rs=0.435
+  lls=0.002
+  lm=0.0693
+  llr=0.002
+  rr=0.816
+  j=0.089
+  ls=0
+  lr=0
+  le=0
+  l1=0
+  l2=0
+  l3=0
+  x1=0
+  x2=0
stparms:
+  psids0=0
+  psiqs0=0
+  psidr0=0
+  psiqr0=0
+  wrm0=0
igparms:
outparms:
+  wrm
+  tem
+  vds
+  vqs
+  ia
+  ib
+  ic
n_f= 5
f_1: d_dt(psids)
f_2: d_dt(psiqs)
f_3: d_dt(psidr)
f_4: d_dt(psiqr)
f_5: d_dt(wrm)
n_g= 5
g_1: vds psids psidr
g_2: vqs psiqs psiqr
g_3: wrm psiqr psids psidr
g_4: wrm psidr psiqs psiqr
g_5: tl psids psidr psiqs psiqr
C:
....
....
endC
endxbe
</pre></div>
</td></tr></table></div>
<p>The input variables are
<code class="docutils literal notranslate"><span class="pre">vqs</span></code>, <code class="docutils literal notranslate"><span class="pre">vds</span></code>, <code class="docutils literal notranslate"><span class="pre">tl</span></code>, and the output variable is <code class="docutils literal notranslate"><span class="pre">wrm</span></code>.
In addition, it has internal (auxiliary) variables
<code class="docutils literal notranslate"><span class="pre">psi_ds</span></code>,
<code class="docutils literal notranslate"><span class="pre">psi_dr</span></code>,
<code class="docutils literal notranslate"><span class="pre">psi_qs</span></code>,
<code class="docutils literal notranslate"><span class="pre">psi_qr</span></code>
which are involved in the model equations.
The statements <code class="docutils literal notranslate"><span class="pre">f_1</span></code>, <code class="docutils literal notranslate"><span class="pre">f_2</span></code>, etc.
are used to inform the simulator which derivative is involved in that equation.
The statements <code class="docutils literal notranslate"><span class="pre">g_1</span></code>, <code class="docutils literal notranslate"><span class="pre">g_2</span></code>, etc.
are used to indicate which variables are involved in the right-hand
side of the corresponding equation.</p>
<p>In the induction machine equations,
there are some <em>one-time</em> calculations, e.g., calculation of <span class="math notranslate nohighlight">\(L_e\)</span>
(Eq. <a class="reference internal" href="#equation-eq-indmc2-1">(12)</a>),
which are not required to be performed in every time step. GSEIM provides
a flag for this purpose, as seen from in the following C++ section of the
template.</p>
<div class="highlight-text notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31</pre></div></td><td class="code"><div class="highlight"><pre><span></span>if (G.flags[G.i_one_time_parms]) {
  k4 = 0.5*(sqrt(3.0));

  lls = X.rprm[nr_lls];
  lm  = X.rprm[nr_lm ];
  llr = X.rprm[nr_llr];

  ls = lls + lm;
  lr = llr + lm;
  le = (ls*lr/lm) - lm;
  l1 = lr/(lm*le);
  l2 = 1.0 + (lls/lm);
  l3 = lls/lm;

  X.rprm[nr_ls] = ls;
  X.rprm[nr_lr] = lr;
  X.rprm[nr_le] = le;
  X.rprm[nr_l1] = l1;
  X.rprm[nr_l2] = l2;
  X.rprm[nr_l3] = l3;

  poles = X.iprm[ni_poles];
  p = (double)(poles);
  x1 = 0.75*p*lm;
  x2 = 0.5*p;

  X.rprm[nr_x1] = x1;
  X.rprm[nr_x2] = x2;

  return;
}
</pre></div>
</td></tr></table></div>
<p>When this flag is
set by the main program, the template computes <span class="math notranslate nohighlight">\(L_e\)</span> and other one-time
parameters, and saves them in the <code class="docutils literal notranslate"><span class="pre">X.rprm</span></code> vector. These
parameters need not be computed again during simulation.</p>
<p>Next, we look at the function assignment sections of <code class="docutils literal notranslate"><span class="pre">indmc1.xbe</span></code>:</p>
<div class="highlight-text notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148</pre></div></td><td class="code"><div class="highlight"><pre><span></span>if (G.flags[G.i_trns]) {
  if (G.flags[G.i_explicit]) {
    if (G.flags[G.i_alg_loop]) {
      X.h[nf_1] = X.val_aux[na_psids] - X.val_aux_u[na_psids];
      X.h[nf_2] = X.val_aux[na_psiqs] - X.val_aux_u[na_psiqs];
      X.h[nf_3] = X.val_aux[na_psidr] - X.val_aux_u[na_psidr];
      X.h[nf_4] = X.val_aux[na_psiqr] - X.val_aux_u[na_psiqr];
      X.h[nf_5] = X.val_vr [nvr_wrm ] - X.val_vr_u [nvr_wrm ];
    } else {
      rs  = X.rprm[nr_rs ];
      lls = X.rprm[nr_lls];
      lm  = X.rprm[nr_lm ];
      rr  = X.rprm[nr_rr ];
      j   = X.rprm[nr_j  ];
      le  = X.rprm[nr_le ];
      l1  = X.rprm[nr_l1 ];
      l2  = X.rprm[nr_l2 ];
      l3  = X.rprm[nr_l3 ];
      x1  = X.rprm[nr_x1 ];
      x2  = X.rprm[nr_x2 ];

      vqs = X.val_vr[nvr_vqs];
      vds = X.val_vr[nvr_vds];
      wrm = X.val_vr[nvr_wrm];
      tl  = X.val_vr[nvr_tl ];

      psids = X.val_aux[na_psids];
      psidr = X.val_aux[na_psidr];
      psiqs = X.val_aux[na_psiqs];
      psiqr = X.val_aux[na_psiqr];

      ids = (l1*psids) - (psidr/le);
      iqs = (l1*psiqs) - (psiqr/le);

      idr = (psids/lm) - (l2*ids);
      iqr = (psiqs/lm) - (l2*iqs);

      tem0 = x1*(iqs*idr-ids*iqr);
      wr   = x2*wrm;

      X.f[nf_1] = vds-rs*ids;
      X.f[nf_2] = vqs-rs*iqs;
      X.f[nf_3] = (-wr)*psiqr-rr*idr;
      X.f[nf_4] = ( wr)*psidr-rr*iqr;
      X.f[nf_5] = (tem0-tl)/j;
    }
  } else {
    rs  = X.rprm[nr_rs ];
    lls = X.rprm[nr_lls];
    lm  = X.rprm[nr_lm ];
    rr  = X.rprm[nr_rr ];
    j   = X.rprm[nr_j  ];
    le  = X.rprm[nr_le ];
    l1  = X.rprm[nr_l1 ];
    l2  = X.rprm[nr_l2 ];
    l3  = X.rprm[nr_l3 ];
    x1  = X.rprm[nr_x1 ];
    x2  = X.rprm[nr_x2 ];

    vqs = X.val_vr[nvr_vqs];
    vds = X.val_vr[nvr_vds];
    wrm = X.val_vr[nvr_wrm];
    tl  = X.val_vr[nvr_tl ];

    psids = X.val_aux[na_psids];
    psidr = X.val_aux[na_psidr];
    psiqs = X.val_aux[na_psiqs];
    psiqr = X.val_aux[na_psiqr];

    if (G.flags[G.i_function] || G.flags[G.i_jacobian]) {
      ids = (l1*psids) - (psidr/le);
      iqs = (l1*psiqs) - (psiqr/le);
      idr = (psids/lm) - (l2*ids);
      iqr = (psiqs/lm) - (l2*iqs);
      tem0 = x1*(iqs*idr-ids*iqr);
      wr = x2*wrm;

      if (G.flags[G.i_function]) {
        X.g[ng_1] = vds-rs*ids;
        X.g[ng_2] = vqs-rs*iqs;
        X.g[ng_3] = (-wr)*psiqr-rr*idr;
        X.g[ng_4] = ( wr)*psidr-rr*iqr;
        X.g[ng_5] = (tem0-tl)/j;
      }
    }
    if (G.flags[G.i_jacobian]) {
      ids_psids = l1;
      ids_psidr = -1.0/le;

      iqs_psiqs = l1;
      iqs_psiqr = -1.0/le;

      idr_psids = (1.0/lm) - (l2*ids_psids);
      idr_psidr =          - (l2*ids_psidr);

      iqr_psiqs = (1.0/lm) - (l2*iqs_psiqs);
      iqr_psiqr =          - (l2*iqs_psiqr);

      tem0_iqs =  x1*idr;
      tem0_idr =  x1*iqs;
      tem0_ids = -x1*iqr;
      tem0_iqr = -x1*ids;

      tem0_psids =
        tem0_idr*idr_psids +
        tem0_ids*ids_psids;

      tem0_psidr =
        tem0_idr*idr_psidr +
        tem0_ids*ids_psidr;

      tem0_psiqs =
        tem0_iqs*iqs_psiqs +
        tem0_iqr*iqr_psiqs;

      tem0_psiqr =
        tem0_iqs*iqs_psiqr +
        tem0_iqr*iqr_psiqr;

      wr_wrm = x2;

      J.dgdvr[ng_1][nvr_vds] = 1.0;
      J.dgdaux[ng_1][na_psids] = -rs*ids_psids;
      J.dgdaux[ng_1][na_psidr] = -rs*ids_psidr;

      J.dgdvr[ng_2][nvr_vqs] = 1.0;
      J.dgdaux[ng_2][na_psiqs] = -rs*iqs_psiqs;
      J.dgdaux[ng_2][na_psiqr] = -rs*iqs_psiqr;

      J.dgdvr[ng_3][nvr_wrm] = (-wr_wrm)*psiqr;
      J.dgdaux[ng_3][na_psiqr] = (-wr);
      J.dgdaux[ng_3][na_psids] = -rr*idr_psids;
      J.dgdaux[ng_3][na_psidr] = -rr*idr_psidr;

      J.dgdvr[ng_4][nvr_wrm] = (wr_wrm)*psidr;
      J.dgdaux[ng_4][na_psidr] = wr;
      J.dgdaux[ng_4][na_psiqs] = -rr*iqr_psiqs;
      J.dgdaux[ng_4][na_psiqr] = -rr*iqr_psiqr;

      J.dgdvr[ng_5][nvr_tl] = -1.0/j;
      J.dgdaux[ng_5][na_psids] = tem0_psids/j;
      J.dgdaux[ng_5][na_psidr] = tem0_psidr/j;
      J.dgdaux[ng_5][na_psiqs] = tem0_psiqs/j;
      J.dgdaux[ng_5][na_psiqr] = tem0_psiqr/j;
    }
  }
  return;
}
</pre></div>
</td></tr></table></div>
<p>In the explicit case,
the function <span class="math notranslate nohighlight">\(f_1\)</span> (i.e.,
<code class="docutils literal notranslate"><span class="pre">X.f[nf_1]</span></code>) is computed as per the right-hand side of
Eq. <a class="reference internal" href="#equation-eq-indmc-1">(2)</a>, and so on.
In the implicit case,
the function <span class="math notranslate nohighlight">\(g_1\)</span> is computed in a similar manner. Note that,
in this case, the derivatives of <span class="math notranslate nohighlight">\(g_1\)</span> with respect to each of the variables involved
in that equation are also computed.</p>
<p>The output parameter computation section of the template is
given below:</p>
<div class="highlight-text notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30</pre></div></td><td class="code"><div class="highlight"><pre><span></span>if (G.flags[G.i_outvar]) {
  X.outprm[no_wrm] = X.val_vr[nvr_wrm];
  X.outprm[no_vds] = X.val_vr[nvr_vds];
  X.outprm[no_vqs] = X.val_vr[nvr_vqs];

  psids = X.val_aux[na_psids];
  psidr = X.val_aux[na_psidr];
  psiqs = X.val_aux[na_psiqs];
  psiqr = X.val_aux[na_psiqr];

  le  = X.rprm[nr_le];
  lm  = X.rprm[nr_lm];
  l1  = X.rprm[nr_l1];
  l2  = X.rprm[nr_l2];

  ids = (l1*psids) - (psidr/le);
  iqs = (l1*psiqs) - (psiqr/le);
  idr = (psids/lm) - (l2*ids);
  iqr = (psiqs/lm) - (l2*iqs);

  X.outprm[no_ia] = iqs;
  X.outprm[no_ib] = -0.5*iqs-k4*ids;
  X.outprm[no_ic] = -0.5*iqs+k4*ids;

  x1 = X.rprm[nr_x1];
  tem0 = x1*(iqs*idr-ids*iqr);
  X.outprm[no_tem] = tem0;

  return;
}
</pre></div>
</td></tr></table></div>
<p>For <a class="reference internal" href="#indmc1"><span class="std std-ref">indmc1.xbe</span></a>, the output parameter are
<code class="docutils literal notranslate"><span class="pre">wrm</span></code>, <code class="docutils literal notranslate"><span class="pre">tem</span></code>, <code class="docutils literal notranslate"><span class="pre">vds</span></code>, <code class="docutils literal notranslate"><span class="pre">vqs</span></code>, <code class="docutils literal notranslate"><span class="pre">ia</span></code>, <code class="docutils literal notranslate"><span class="pre">ib</span></code>, <code class="docutils literal notranslate"><span class="pre">ic</span></code>.
To assign the current value of the <em>variable</em> <code class="docutils literal notranslate"><span class="pre">wrm</span></code> to the
<em>output parameter</em> <code class="docutils literal notranslate"><span class="pre">wrm</span></code>, we need to assign
<code class="docutils literal notranslate"><span class="pre">X.outprm[no_wrm]</span></code>, and so on. Note that
<code class="docutils literal notranslate"><span class="pre">ia</span></code>, <code class="docutils literal notranslate"><span class="pre">ib</span></code>, <code class="docutils literal notranslate"><span class="pre">ic</span></code>, <code class="docutils literal notranslate"><span class="pre">tem</span></code> are not readily available (they
are not input, output, or auxiliary variables of this template),
and therefore need to be computed and then assigned.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">GSEIM</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">GSEIM Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="new_project.html">Creating a new project</a></li>
<li class="toctree-l1"><a class="reference internal" href="organisation.html">GSEIM Organisation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Element templates (<code class="docutils literal notranslate"><span class="pre">xbe</span></code>)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#xbe-template-examples"><code class="docutils literal notranslate"><span class="pre">xbe</span></code> template examples</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="functions.html"><code class="docutils literal notranslate"><span class="pre">f</span></code>, <code class="docutils literal notranslate"><span class="pre">g</span></code>, <code class="docutils literal notranslate"><span class="pre">h</span></code> functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="solve.html">Solve Blocks</a></li>
<li class="toctree-l1"><a class="reference internal" href="subckt.html">Subcircuits</a></li>
<li class="toctree-l1"><a class="reference internal" href="xbedocs.html">xbe Documents</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="organisation.html" title="previous chapter">GSEIM Organisation</a></li>
      <li>Next: <a href="functions.html" title="next chapter"><code class="docutils literal notranslate"><span class="pre">f</span></code>, <code class="docutils literal notranslate"><span class="pre">g</span></code>, <code class="docutils literal notranslate"><span class="pre">h</span></code> functions</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, Mahesh Patil.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.8</a>
      
      |
      <a href="_sources/xbe.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>